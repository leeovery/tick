AGENT: architecture
FINDINGS:
- FINDING: handleRemove uses Mutate for read-only blast radius computation, causing unnecessary JSONL rewrite
  SEVERITY: high
  FILES: internal/cli/app.go:233, internal/cli/remove.go:52
  DESCRIPTION: When --force is not set, handleRemove calls store.Mutate() with computeOnly=true to compute the blast radius for the confirmation prompt. The executeRemoval function returns the original task slice unmodified when computeOnly is true, but Store.Mutate always rewrites the JSONL file and rebuilds the SQLite cache with whatever the callback returns. This means every non-forced remove rewrites the entire JSONL file unnecessarily (marshalling and atomically writing the same data back) before even showing the prompt. If the user declines, the file was rewritten for nothing. Worse, re-marshalling could introduce subtle byte-level differences (e.g., field ordering, whitespace) compared to the original file, which would change the file's MD5 hash and trigger unnecessary cache rebuilds on subsequent operations.
  RECOMMENDATION: Extract the read-only blast radius computation out of Store.Mutate. Two options: (1) Add a Store.ReadAll method that returns the task slice without acquiring an exclusive lock or writing, then call executeRemoval outside Mutate purely for blast radius computation. (2) Alternatively, use Store.Query with a SQL query to gather the blast radius information (IDs, titles, parent relationships, BlockedBy) without needing the full in-memory slice. Either approach avoids the spurious rewrite.
- FINDING: Double store open creates TOCTOU gap between confirmation and actual removal
  SEVERITY: medium
  FILES: internal/cli/app.go:228-247
  DESCRIPTION: handleRemove opens the store once to compute blast radius (lines 228-238), closes it, runs the interactive confirmation prompt, then delegates to RunRemove which opens the store a second time for the actual mutation (line 247). Between the first close and the second open, another process (or the user in another terminal) could modify the JSONL file -- adding, removing, or changing tasks. The blast radius shown in the prompt may no longer match reality when the removal executes. A task could be removed by another process (causing the second Mutate to fail with "not found"), or new children/dependencies could be added that the user was never warned about. This is the classic time-of-check-to-time-of-use pattern. For a single-user CLI tool the practical risk is low, but the architecture creates a window where the confirmation is stale.
  RECOMMENDATION: Keep the store open across both the blast radius computation and the actual removal. Instead of delegating to RunRemove (which re-opens the store), inline the confirmation + mutation into a single handleRemove flow that holds the store open (and ideally the exclusive lock) throughout. The formatter output logic from RunRemove is only a few lines and can be shared via a helper.
- FINDING: executeRemoval boolean parameter controls two fundamentally different behaviors
  SEVERITY: medium
  FILES: internal/cli/remove.go:52
  DESCRIPTION: The computeOnly boolean parameter makes executeRemoval serve two purposes: (1) read-only blast radius computation that returns the original slice, and (2) actual removal that filters and cleans dependencies. The function signature returns four values (tasks, blastRadius, RemovalResult, error) but callers only use a subset depending on the boolean -- computeOnly=true callers ignore RemovalResult, and computeOnly=false callers ignore blastRadius. This violates the single-responsibility principle and makes the function harder to reason about. The boolean parameter is flagged as an anti-pattern in code-quality.md.
  RECOMMENDATION: Split into two functions: computeBlastRadius(tasks, ids) (blastRadius, error) for the confirmation path, and applyRemoval(tasks, ids) ([]task.Task, RemovalResult, error) for the mutation path. Both can share internal helpers (collectDescendants, validation) without requiring a mode flag.
SUMMARY: The primary structural issue is that handleRemove abuses Store.Mutate for read-only blast radius computation, causing unnecessary JSONL rewrites on every non-forced remove. This compounds with a double-store-open pattern that creates a TOCTOU gap between confirmation and execution. Splitting the dual-purpose executeRemoval function would clarify intent and enable cleaner integration with the store's read/write APIs.
