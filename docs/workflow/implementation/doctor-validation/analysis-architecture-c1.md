AGENT: architecture
FINDINGS:
- FINDING: Repeated file parsing across relationship checks -- tasks.jsonl read 6 times per doctor run
  SEVERITY: medium
  FILES: internal/doctor/orphaned_parent.go:21, internal/doctor/orphaned_dependency.go:17, internal/doctor/self_referential_dep.go:18, internal/doctor/dependency_cycle.go:20, internal/doctor/child_blocked_by_parent.go:22, internal/doctor/parent_done_open_children.go:20
  DESCRIPTION: Six checks each independently call ParseTaskRelationships(tickDir), which opens, reads, and parses the entire tasks.jsonl file from disk. In a single doctor run all 6 relationship checks parse the same file independently. The first 4 checks (cache, jsonl syntax, id format, duplicate ID) also each independently open and scan tasks.jsonl. That means the file is opened and fully parsed ~10 times per run. For the relationship checks specifically, each call produces identical TaskRelationshipData slices. This is not just I/O waste -- if the file changes between reads during a check run (unlikely but possible), checks would see inconsistent snapshots.
  RECOMMENDATION: Parse tasks.jsonl once and pass the parsed data to checks that need it. Two options: (1) Add a pre-parse phase to DiagnosticRunner that runs ParseTaskRelationships once and stores the result in the context alongside TickDirKey, so relationship checks pull from context rather than re-parsing. (2) Have RunDoctor parse once and pass a TaskRelationshipData key in the context. Option 1 keeps the runner in control and is cleaner. The first 4 checks (cache, syntax, id, dup) each need raw file access differently so they can stay as-is, but the 6 relationship checks share identical parsing.

- FINDING: Context-based dependency passing bypasses type safety
  SEVERITY: medium
  FILES: internal/cli/doctor.go:30, internal/doctor/doctor.go:13, internal/doctor/cache_staleness.go:24, internal/doctor/jsonl_syntax.go:24, internal/doctor/id_format.go:28
  DESCRIPTION: The tick directory path is passed to checks via context.WithValue using TickDirKey. Every check starts with `tickDir, _ := ctx.Value(TickDirKey).(string)` -- a runtime type assertion that silently returns empty string on failure. This is the "untyped parameters when concrete types are known" anti-pattern from code-quality.md. The Check interface method `Run(ctx context.Context) []CheckResult` forces all configuration through the context bag, but every check needs the same string path. If the key is missing or the wrong type, checks silently produce confusing "tick directory path not set" errors (or worse, in JsonlSyntaxCheck and others that don't guard against empty tickDir, they'd try to open "/tasks.jsonl").
  RECOMMENDATION: Change the Check interface to `Run(ctx context.Context, tickDir string) []CheckResult`. This makes the dependency explicit, eliminates the runtime type assertion in every check, and prevents the silent-empty-string failure mode. The context parameter can remain for future extensibility (cancellation, etc.) but should not carry the primary configuration.

- FINDING: Inconsistent empty-tickDir guarding across checks
  SEVERITY: low
  FILES: internal/doctor/cache_staleness.go:26, internal/doctor/jsonl_syntax.go:24-25, internal/doctor/id_format.go:28-29
  DESCRIPTION: CacheStalenessCheck explicitly guards against empty tickDir with a check on line 26. However, JsonlSyntaxCheck, IdFormatCheck, DuplicateIdCheck, and all six relationship checks do not guard against empty tickDir -- they proceed to construct a path like filepath.Join("", "tasks.jsonl") which resolves to "tasks.jsonl" in the current directory. This inconsistency means that if TickDirKey is missing from context, CacheStalenessCheck returns a helpful error while all other checks would attempt to open a relative path, likely failing with a different error message or (in a pathological case) reading a tasks.jsonl that happens to exist in the working directory.
  RECOMMENDATION: Either add the same empty-tickDir guard to all checks (boilerplate), or resolve this by making tickDir a required parameter on the Check interface as recommended above, which eliminates the problem structurally.

SUMMARY: The architecture is clean in its core abstractions (Check interface, DiagnosticRunner, DiagnosticReport, formatting). The main structural issues are: 6 relationship checks redundantly re-parse the same file on every run, and the context-bag pattern for passing tickDir bypasses type safety with inconsistent error handling across checks.
