AGENT: architecture
FINDINGS:
- FINDING: RunRemove signature diverges from handler convention with extra io parameters
  SEVERITY: medium
  FILES: internal/cli/remove.go:147, internal/cli/app.go:215
  DESCRIPTION: Every other Run* handler follows the signature pattern `Run*(dir, fc, fmtr, args, stdout)`. RunRemove adds stdin and stderr as separate parameters, giving it 7 arguments (violating the 4+ long-parameter-list guideline). The App struct already holds Stdin and Stderr, and handleRemove already has access to both. The precedent set by RunDoctor (which receives stdout and stderr directly) is a different case -- doctor bypasses the format/formatter pipeline entirely. For a standard formatter-based command, the extra io parameters break the uniform handler contract.
  RECOMMENDATION: Pass stdin and stderr through a struct or accept them as a config parameter. The simplest option consistent with the existing pattern: pass `a.Stdin` and `a.Stderr` as a single `PromptIO` struct (with Reader and Writer fields), reducing RunRemove to `RunRemove(dir, fc, fmtr, args, promptIO, stdout)` at 6 params -- or better, embed prompt IO in FormatConfig since it is command-pipeline configuration. Alternatively, since handleRemove already has access to `a`, the confirmation logic could be pulled into handleRemove before calling a slimmer RunRemove that only does the mutation.

- FINDING: Duplicate validation logic between computeBlastRadius and RunRemove Mutate callback
  SEVERITY: medium
  FILES: internal/cli/remove.go:63-111, internal/cli/remove.go:172-184
  DESCRIPTION: Both computeBlastRadius (lines 63-111) and the Mutate callback (lines 172-193) independently validate that all IDs exist and compute the full set of descendants. The two code paths use different data sources (SQLite via Query vs in-memory task slice via Mutate) and different algorithms (iterative expansion vs parent-index walk). This creates a TOCTOU window: if another process modifies the JSONL between the Query (blast radius computation) and the Mutate (actual removal), the blast radius shown in the prompt could differ from what is actually removed. The Mutate callback's validation is the authoritative path, but the prompt's blast radius is computed from a potentially stale read. More practically, having two independent implementations of descendant collection means they must be kept in sync.
  RECOMMENDATION: Since the Mutate callback is the authoritative path and already validates + collects descendants, consider computing the blast radius from the task slice inside Mutate rather than from a separate Query. One approach: run Mutate with a "dry run" flag that computes but does not persist, use that result for the prompt, then run Mutate again for real if confirmed. Alternatively, accept the TOCTOU gap as inherent to the confirmation pattern (the prompt is advisory), but consolidate the descendant-collection algorithm to a single implementation. Currently collectDescendants serves Mutate; computeBlastRadius reimplements the same logic against SQL. computeBlastRadius could be refactored to call collectDescendants on a task slice loaded via Query instead of writing raw SQL.

- FINDING: computeBlastRadius uses an inline interface instead of the concrete Store type
  SEVERITY: low
  FILES: internal/cli/remove.go:58-60
  DESCRIPTION: computeBlastRadius declares an anonymous interface `interface{ Query(func(*sql.DB) error) error }` as its first parameter. No other function in the cli package does this -- all other handlers use `*storage.Store` directly via the openStore helper. The inline interface adds indirection without providing testability benefit (the function is not independently tested with a mock store; all tests use real stores). It also creates an inconsistency with how the rest of the codebase accesses the store.
  RECOMMENDATION: Accept `*storage.Store` directly, matching all other handlers. If testability of computeBlastRadius in isolation is desired in the future, define a named interface at the package level rather than inline.

SUMMARY: The implementation is structurally sound with good test coverage across formatters, cascade logic, and confirmation flows. The main architectural concerns are the RunRemove signature diverging from the established handler convention (7 params vs the standard 5), and the descendant-collection logic being implemented twice via different data sources (SQL query vs in-memory task slice), creating a maintenance burden and a theoretical TOCTOU gap.
