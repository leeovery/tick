# Task tick-core-3-3: Ready Query & tick ready Command

## Task Summary

Implement the core "what should I work on next?" feature. A task is **ready** when it satisfies three conditions: (1) status is `open`, (2) all blockers are `done` or `cancelled`, and (3) it has no children with status `open` or `in_progress`. Build a reusable `ReadyQuery` SQL query function and a `tick ready` CLI command that aliases `tick list --ready`. Output should use aligned columns matching `tick list`, print `No tasks found.` (exit 0) when empty, and support `--quiet` for IDs-only output. Ordering is priority ASC, created ASC (deterministic).

### Acceptance Criteria (from plan)

1. Returns tasks matching all three conditions (open, unblocked, no open children)
2. Open/in_progress blockers exclude task
3. Open/in_progress children exclude task
4. Cancelled blockers unblock
5. Only `open` status returned
6. Deep nesting handled correctly
7. Deterministic ordering (priority ASC, created ASC)
8. `tick ready` outputs aligned columns
9. Empty result prints `No tasks found.`, exit 0
10. `--quiet` outputs IDs only
11. Query function reusable by blocked query and list filters

## Acceptance Criteria Compliance

| Criterion | V2 | V4 |
|-----------|-----|-----|
| Returns tasks matching all three conditions | PASS -- ReadySQL constant with correct WHERE clause; tested in `TestReadyQuery/"it returns open task..."` | PASS -- readyQuery variable with correct WHERE clause; tested in `TestReady_OpenTaskNoBlockersNoChildren` |
| Open/in_progress blockers exclude task | PASS -- Tested separately for open and in_progress blockers | PASS -- Tested separately for open and in_progress blockers |
| Open/in_progress children exclude task | PASS -- Tested for open children and in_progress children separately | PASS -- Tested for open children and in_progress children separately |
| Cancelled blockers unblock | PASS -- Test uses both `done` and `cancelled` blockers | PASS -- Test uses both `done` and `cancelled` blockers with proper `Closed` field |
| Only `open` status returned | PASS -- Tests for in_progress, done, cancelled exclusion (3 separate subtests) | PASS -- Single test covers all three non-open statuses in one scenario |
| Deep nesting handled correctly | PASS -- Grandparent/parent/child test; only leaf appears | PASS -- Grandparent/parent/child test; only leaf appears |
| Deterministic ordering | PASS -- 4-task ordering test: pri 1 (2 tasks by created), pri 2, pri 3 | PASS -- 4-task ordering test: pri 1 (2 tasks by created), pri 2, pri 3 |
| `tick ready` outputs aligned columns | PASS -- Verifies header columns and column alignment positions | PARTIAL -- Verifies output contains data but checks for TOON format `tasks[` header rather than `ID/STATUS/PRI/TITLE` columns |
| Empty result prints `No tasks found.`, exit 0 | PASS -- Checks exact string `"No tasks found."` | FAIL -- Tests check for `tasks[0]` (TOON format) rather than `"No tasks found."` |
| `--quiet` outputs IDs only | PASS -- Verifies 2 lines with exact ID values | PASS -- Verifies 2 lines with exact ID values |
| Query function reusable by blocked query and list filters | PASS -- Exports `ReadySQL` const plus `readyWhere`/`blockedWhere` fragments; `buildListQuery` reuses them | PASS -- `readyConditionsFor("t")` function reused by `readyQuery`, `blockedQuery`, and `buildListQuery` |

## Implementation Comparison

### Approach

**V2: Inline in list.go with WHERE clause fragments**

V2 keeps all ready logic inside `list.go`. It defines reusable WHERE clause fragments as string constants, then composes them into full SQL queries:

```go
// list.go
const readyWhere = `status = 'open'
  AND id NOT IN (
    SELECT d.task_id FROM dependencies d
    JOIN tasks t ON d.blocked_by = t.id
    WHERE t.status NOT IN ('done', 'cancelled')
  )
  AND id NOT IN (
    SELECT parent FROM tasks WHERE parent IS NOT NULL AND status IN ('open', 'in_progress')
  )`

const ReadySQL = `SELECT id, status, priority, title FROM tasks
WHERE ` + readyWhere + `
ORDER BY priority ASC, created ASC`
```

The `tick ready` command is dispatched in `app.go` as a simple alias:

```go
case "ready":
    return a.runList([]string{"--ready"})
```

V2's `buildListQuery` dynamically composes SQL by appending WHERE conditions for `--ready`, `--blocked`, `--status`, and `--priority` flags. The `readyWhere` and `blockedWhere` fragments are embedded directly into the query string.

**V4: Separate ready.go with parameterized condition function**

V4 creates a dedicated `ready.go` file with its own `runReady` method. The ready conditions are generated by a function that accepts a table alias parameter:

```go
// ready.go
func readyConditionsFor(alias string) string {
    return `
  NOT EXISTS (
    SELECT 1 FROM dependencies d
    JOIN tasks blocker ON d.blocked_by = blocker.id
    WHERE d.task_id = ` + alias + `.id
      AND blocker.status NOT IN ('done', 'cancelled')
  )
  AND NOT EXISTS (
    SELECT 1 FROM tasks child
    WHERE child.parent = ` + alias + `.id
      AND child.status IN ('open', 'in_progress')
  )`
}
```

The `tick ready` command has its own case in `cli.go`:

```go
case "ready":
    if err := a.runReady(subArgs); err != nil {
        a.writeError(err)
        return 1
    }
    return 0
```

V4's `runReady` is a standalone method that queries the database directly using `readyQuery`, while `list.go` handles `--ready` by reusing the same `readyConditionsFor` function inside `buildListQuery`.

**Key structural differences:**

1. **File organization**: V2 keeps everything in `list.go`; V4 separates into `ready.go` + `list.go`
2. **SQL approach**: V2 uses `NOT IN` subqueries; V4 uses `NOT EXISTS` with correlated subqueries
3. **Reuse mechanism**: V2 uses string constant composition (`readyWhere` + concatenation); V4 uses a function `readyConditionsFor(alias)` that accepts a table alias
4. **Command dispatch**: V2 aliases `ready` to `runList([]string{"--ready"})`; V4 has a dedicated `runReady` handler
5. **Rendering**: V2 delegates to `a.formatter.FormatTaskList(a.stdout, taskRows)` (no quiet param -- quiet handled earlier); V4 delegates to `a.Formatter.FormatTaskList(a.Stdout, rows, a.Quiet)` passing quiet as a parameter

### Code Quality

**SQL correctness and idioms:**

V2 uses `NOT IN` subqueries:
```sql
AND id NOT IN (
    SELECT d.task_id FROM dependencies d
    JOIN tasks t ON d.blocked_by = t.id
    WHERE t.status NOT IN ('done', 'cancelled')
)
```

V4 uses `NOT EXISTS` with correlated subqueries:
```sql
AND NOT EXISTS (
    SELECT 1 FROM dependencies d
    JOIN tasks blocker ON d.blocked_by = blocker.id
    WHERE d.task_id = t.id
      AND blocker.status NOT IN ('done', 'cancelled')
)
```

`NOT EXISTS` is generally considered the more correct SQL idiom -- it handles NULL values better and is often better optimized by query planners. V4's approach is genuinely better here.

V4 also aliases the joined table as `blocker` instead of `t` (which V2 reuses, creating ambiguity with the outer query's unaliased table name). In V2's `readyWhere`, the outer `tasks` table is not aliased while the inner join uses `t`, creating potential confusion. In V4's `readyConditionsFor`, the alias is parameterized, making it explicit and safe for reuse in different query contexts.

**Reusability:**

V2 exports `ReadySQL` as a `const` and keeps `readyWhere`/`blockedWhere` as package-level constants. The `buildListQuery` embeds these fragments directly:
```go
if flags.ready {
    where = append(where, "("+readyWhere+")")
}
```

V4's `readyConditionsFor(alias)` is genuinely better for reuse because it accepts a table alias parameter, making it safe to use in subqueries where the table might have a different alias:
```go
// In buildListQuery for --blocked with combined filters:
query += " AND t.status = 'open' AND t.id NOT IN (SELECT t2.id FROM tasks t2 WHERE t2.status = 'open' AND" +
    readyConditionsFor("t2") + ")"
```

**Rendering delegation:**

V2 handles quiet mode inside `runList` before calling the formatter, then converts to `TaskRow` types:
```go
if a.config.Quiet {
    if len(rows) == 0 {
        return nil
    }
    for _, r := range rows {
        fmt.Fprintln(a.stdout, r.ID)
    }
    return nil
}
taskRows := make([]TaskRow, len(rows))
for i, r := range rows {
    taskRows[i] = TaskRow{...}
}
return a.formatter.FormatTaskList(a.stdout, taskRows)
```

V4 passes `quiet` to the formatter, keeping the rendering concern in the formatter:
```go
return a.Formatter.FormatTaskList(a.Stdout, rows, a.Quiet)
```

V4's approach is cleaner -- quiet mode is a rendering concern and belongs in the formatter.

**Type definitions:**

V2 defines `listRow` as a local type inside `runList`, and has a separate `TaskRow` in `formatter.go` for the formatter interface. This means V2 has to convert between the two. V4 defines `listRow` at the package level in `list.go` and uses it directly in the `Formatter` interface, avoiding the conversion step.

**Error handling:**

Both versions handle errors identically in the query path. V4's `App.Run` returns an `int` exit code and writes errors to stderr via `writeError`, while V2's `App.Run` returns an `error`. V4's approach is more conventional for CLI apps (exit codes rather than error returns).

### Test Quality

**V2 Test Functions (in `ready_test.go`, 510 lines):**

All tests are under two top-level functions with subtests:

1. `TestReadyQuery` -- 14 subtests:
   - `"it returns open task with no blockers and no children"` -- single open task
   - `"it excludes task with open blocker"` -- open blocker blocks dependent
   - `"it excludes task with in_progress blocker"` -- in_progress blocker blocks
   - `"it includes task when all blockers done or cancelled"` -- mixed done+cancelled blockers
   - `"it excludes parent with open children"` -- parent excluded, child included
   - `"it excludes parent with in_progress children"` -- parent excluded
   - `"it includes parent when all children closed"` -- done+cancelled children, parent included
   - `"it excludes in_progress tasks"` -- checks "No tasks found."
   - `"it excludes done tasks"` -- checks "No tasks found."
   - `"it excludes cancelled tasks"` -- checks "No tasks found."
   - `"it handles deep nesting -- only deepest incomplete ready"` -- 3-level nesting
   - `"it returns empty list when no tasks ready"` -- all blocked scenario
   - `"it orders by priority ASC then created ASC"` -- 4 tasks, verifies line positions
   - `"it outputs aligned columns via tick ready"` -- header + column alignment verification
   - `"it prints 'No tasks found.' when empty"` -- empty store
   - `"it outputs IDs only with --quiet"` -- verifies 2 IDs, exact values

2. `TestReadyViaListFlag` -- 1 subtest:
   - `"it works via list --ready flag as well"` -- verifies `tick list --ready` works

**Total V2: 2 test functions, 15 subtests**

V2 test setup uses a raw JSONL helper `taskJSONL(...)` that manually constructs JSON strings with a custom `itoa` function. Tests use `strings.Builder` for stdout and `app.Run([]string{"tick", "ready"})` invocations. Several tests add `"--pretty"` to force the pretty formatter for output that checks "No tasks found.".

**V4 Test Functions (in `ready_test.go`, 490 lines):**

Each scenario gets its own top-level test function with a single subtest:

1. `TestReady_OpenTaskNoBlockersNoChildren` -- 1 subtest
2. `TestReady_ExcludesTaskWithOpenBlocker` -- 1 subtest
3. `TestReady_ExcludesTaskWithInProgressBlocker` -- 1 subtest
4. `TestReady_IncludesTaskWhenAllBlockersDoneOrCancelled` -- 1 subtest
5. `TestReady_ExcludesParentWithOpenChildren` -- 1 subtest
6. `TestReady_ExcludesParentWithInProgressChildren` -- 1 subtest
7. `TestReady_IncludesParentWhenAllChildrenClosed` -- 1 subtest
8. `TestReady_ExcludesNonOpenStatuses` -- 1 subtest (tests all three non-open in one scenario)
9. `TestReady_DeepNesting` -- 1 subtest
10. `TestReady_EmptyList` -- 1 subtest
11. `TestReady_OrderByPriorityThenCreated` -- 1 subtest
12. `TestReady_AlignedColumnsOutput` -- 1 subtest
13. `TestReady_NoTasksFoundMessage` -- 1 subtest
14. `TestReady_QuietFlag` -- 1 subtest

**Total V4: 14 test functions, 14 subtests**

V4 test setup uses typed `task.Task` structs and a `setupInitializedDirWithTasks` helper. Tests use `bytes.Buffer` for stdout/stderr and check `app.Run` return code (int). V4 imports `task` package types (`task.StatusOpen`, `task.StatusDone`, etc.) and uses `time.Date` for creating timestamps.

**Test coverage comparison:**

| Edge Case | V2 | V4 |
|-----------|-----|-----|
| Simple open task, no blockers, no children | Yes | Yes |
| Open blocker exclusion | Yes | Yes |
| In_progress blocker exclusion | Yes | Yes |
| All blockers done/cancelled | Yes | Yes |
| Parent with open children | Yes | Yes |
| Parent with in_progress children | Yes | Yes |
| Parent with all children closed | Yes | Yes |
| Exclude in_progress tasks | Yes (separate test) | Yes (combined test) |
| Exclude done tasks | Yes (separate test) | Yes (combined test) |
| Exclude cancelled tasks | Yes (separate test) | Yes (combined test) |
| Deep nesting (3 levels) | Yes | Yes |
| Empty result (no ready tasks) | Yes | Yes |
| Ordering verification | Yes | Yes |
| Aligned column output | Yes | Yes |
| No tasks found message | Yes | FAIL (checks `tasks[0]` instead of `No tasks found.`) |
| Quiet mode | Yes | Yes |
| `tick list --ready` alias | Yes | No (missing) |

**Test gaps:**

- V4 is missing a test for `tick list --ready` (the alias route via list command). V2 explicitly tests this in `TestReadyViaListFlag`.
- V4's empty result tests check for `tasks[0]` (TOON format header) instead of the spec-required `"No tasks found."` message. This means V4's tests would pass even though the acceptance criterion for "No tasks found." output is not being validated. The TOON formatter apparently outputs `tasks[0]` for empty lists rather than `"No tasks found."`.
- V4's column alignment test checks for TOON format headers (`tasks[`, `id`, `status`, `priority`, `title`) rather than the spec-mandated aligned columns (`ID`, `STATUS`, `PRI`, `TITLE`). The spec says "aligned columns like tick list" which references the pretty format.

**Test setup approach:**

V2 uses raw JSONL string construction:
```go
func taskJSONL(id, title, status string, priority int, blockedBy []string, parent string, created string) string {
    line := `{"id":"` + id + `","title":"` + title + `","status":"` + status + ...
```

V4 uses typed structs:
```go
tasks := []task.Task{
    {ID: "tick-aaa111", Title: "Simple task", Status: task.StatusOpen, Priority: 2, Created: now, Updated: now},
}
dir := setupInitializedDirWithTasks(t, tasks)
```

V4's approach is genuinely better: it uses typed constants for status values, proper `time.Time` values, and struct literals that the compiler validates. V2's string construction could silently produce invalid JSON.

## Diff Stats

| Metric | V2 | V4 |
|--------|-----|-----|
| Files changed | 3 (app.go, list.go, ready_test.go) | 4 (cli.go, list.go, ready.go, ready_test.go) |
| Lines added | 551 | 600 |
| Lines removed | 6 | 28 |
| Impl LOC (list.go relevant additions) | ~43 net new in list.go, 2 in app.go | 70 in ready.go, 62 net changed in list.go, 6 in cli.go |
| Test LOC | 510 | 490 |
| Test functions | 2 (15 subtests) | 14 (14 subtests) |

## Verdict

**V2 is the better implementation of this specific task**, primarily due to acceptance criteria compliance, while V4 shows better engineering in several areas.

**V2 wins on correctness:**
- V2's tests validate the exact `"No tasks found."` message required by the spec. V4's tests check for `tasks[0]` (TOON format), which does not match the acceptance criterion.
- V2 explicitly tests `tick list --ready` as an alias, fulfilling the spec requirement that `tick ready` is an alias for `list --ready`. V4 omits this test.
- V2's aligned columns test validates the `ID`, `STATUS`, `PRI`, `TITLE` header format and checks column position alignment. V4's test checks for TOON format headers.

**V4 wins on engineering quality:**
- `NOT EXISTS` subqueries are more correct SQL than `NOT IN` (NULL-safe, better optimizer hints).
- `readyConditionsFor(alias)` is a superior reuse mechanism compared to string constant composition, because it safely handles different table aliases in nested queries.
- Separate `ready.go` file is better file organization for a dedicated command.
- Typed test setup (`task.Task` structs, `task.StatusOpen` constants, `time.Date`) is more robust than raw JSONL string construction.
- The `Formatter.FormatTaskList(w, rows, quiet)` interface design properly delegates quiet mode to the formatter.

The acceptance criteria failures in V4 appear to be a formatter integration issue: V4's default non-TTY format is TOON, which renders empty lists as `tasks[0]` rather than `"No tasks found."`. The underlying ready query logic is correct in both versions. However, since the task spec explicitly requires `"No tasks found."` output and aligned `ID/STATUS/PRI/TITLE` columns, V2's test coverage of these requirements makes it the more compliant implementation.
