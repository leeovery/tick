{"id":"tick-132530","title":"Task Removal","status":"done","priority":2,"created":"2026-02-19T11:10:08Z","updated":"2026-02-19T15:18:33Z","closed":"2026-02-19T15:18:33Z"}
{"id":"tick-cf0a05","title":"Phase 1: Walking Skeleton — Single Task Removal","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T11:10:11Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-7314b0","title":"Add FormatRemoval to Formatter interface and all implementations","status":"done","priority":1,"description":"Problem: The Formatter interface has no method for rendering task removal output. Removal is a distinct operation -- not a status transition, dependency change, or generic message. Without a dedicated FormatRemoval method, the RunRemove handler has no way to render structured removal output through the formatter pipeline.\n\nSolution: Add FormatRemoval(result RemovalResult) string to the Formatter interface. Define RemovalResult and RemovedTask structs. Implement on all four formatter types: ToonFormatter, PrettyFormatter (both via baseFormatter embedding), JSONFormatter (structured JSON), and StubFormatter (empty string).\n\nOutcome: The Formatter interface includes FormatRemoval. All four implementations compile and pass tests. Output renders removed task IDs/titles and optional dependency update info.\n\nDo:\n1. Define RemovedTask struct (ID, Title) and RemovalResult struct (Removed []RemovedTask, DepsUpdated []string) in internal/cli/format.go\n2. Add FormatRemoval(result RemovalResult) string to the Formatter interface\n3. Add FormatRemoval to StubFormatter returning empty string\n4. Implement FormatRemoval on baseFormatter: one line per removed task as \"Removed {id} \\\"{title}\\\"\", plus \"Updated dependencies on {id1}, {id2}\" line if DepsUpdated non-empty, joined by newline\n5. ToonFormatter and PrettyFormatter inherit from baseFormatter (no extra code)\n6. Implement FormatRemoval on JSONFormatter: jsonRemovalResult with removed []jsonRemovedTask and deps_updated []string, both always [] not null, via marshalIndentJSON\n7. Add tests in existing test files for each formatter\n\nAcceptance Criteria:\n- Formatter interface includes FormatRemoval(result RemovalResult) string\n- All four formatters satisfy the updated interface (compile-time checks)\n- Toon/Pretty: single removal outputs \"Removed tick-a1b2 \\\"My task\\\"\"\n- JSON: valid JSON with removed array and deps_updated array\n- JSON arrays are [] not null when empty\n- Multiple removed tasks produce one line each (text) or array entries (JSON)\n- DepsUpdated non-empty produces dependency update line/field\n- All existing tests pass\n\nTests:\n- it formats single task removal\n- it formats multiple task removal\n- it formats removal with dependency updates\n- it formats removal with empty deps_updated as empty slice in JSON\n- it formats removal with empty removed as empty slice in JSON\n- it satisfies Formatter interface (compile-time, no regression)\n- StubFormatter.FormatRemoval returns empty string\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:10:18Z","updated":"2026-02-19T13:39:23Z","closed":"2026-02-19T13:39:23Z"}
{"id":"tick-64566b","title":"Implement RunRemove handler with --force flag and wire into App.Run","status":"done","priority":1,"description":"## Problem\n\nTick has no way to permanently delete tasks. The cancel command marks a task as resolved-but-present; there is no mechanism to filter a task out of the JSONL file entirely. The remove command needs a handler that accepts a single task ID, locates the task, filters it from the task slice inside Store.Mutate(), and cleans up dependency references on surviving tasks. The --force flag is required to skip confirmation since this is Phase 1 (confirmation prompts are deferred to a later phase).\n\n## Solution\n\nCreate a RunRemove function in internal/cli/remove.go following the established handler pattern (RunTransition, RunDepAdd). The handler parses --force/-f from subArgs, normalizes the task ID (case-insensitive via task.NormalizeID), opens the store, and calls Store.Mutate(). Inside Mutate, it finds the target task, filters it out of the slice, and strips the removed ID from all surviving tasks' BlockedBy arrays. The result is formatted via the FormatRemoval method (added by task-removal-1-1) and output to stdout. Wire the handler into App.Run via a new handleRemove method dispatched from the switch in app.go.\n\nNote: This task implements single-task removal with --force only. Interactive confirmation (without --force), cascade deletion, bulk removal, and no-args error handling are covered by subsequent tasks.\n\n## Outcome\n\nRunning tick remove tick-abc123 --force removes the task from JSONL, cleans up dependency references on surviving tasks, and outputs the removal result through all three formatters. The command is accessible via tick remove in the CLI dispatch. Case-insensitive ID matching works (e.g., TICK-ABC123 matches tick-abc123).\n\n## Do\n\n1. Create internal/cli/remove.go:\n   - Define parseRemoveArgs(args []string) (id string, force bool, err error) that iterates args, extracts --force/-f as a boolean flag, collects the first positional argument as the task ID (normalized via task.NormalizeID), and returns an error if --force is not set. Error message: \"remove requires --force flag (interactive confirmation not yet implemented)\".\n   - Define RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdout io.Writer) error:\n     - Call parseRemoveArgs(args) to get the ID and force flag.\n     - If no ID provided, return error: \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...] --force\".\n     - Call openStore(dir, fc) and defer store.Close().\n     - Build a RemovalResult to capture output data.\n     - Call store.Mutate: find target task by comparing task.NormalizeID on both sides. If not found, return error \"task '%s' not found\". Record task ID and Title in RemovalResult.Removed. Filter out the task. Iterate remaining tasks and strip removed ID from BlockedBy arrays, recording affected task IDs in RemovalResult.DepsUpdated. Return filtered slice.\n     - If \\!fc.Quiet, output fmtr.FormatRemoval(result) via fmt.Fprintln(stdout, ...).\n\n2. Add handleRemove method to App in internal/cli/app.go:\n   - Follow the pattern of handleTransition: resolve working directory, call RunRemove.\n   - Add case \"remove\": to the switch statement in App.Run.\n\n3. Create internal/cli/remove_test.go with tests listed below.\n\n## Acceptance Criteria\n\n- [ ] tick remove tick-abc123 --force removes the task from JSONL\n- [ ] tick remove TICK-ABC123 --force finds and removes tick-abc123 (case-insensitive)\n- [ ] Surviving tasks with removed task in BlockedBy have that reference stripped\n- [ ] RemovalResult.DepsUpdated lists IDs of tasks whose deps were cleaned up\n- [ ] Output goes through fmtr.FormatRemoval(result) and respects --quiet\n- [ ] tick remove without --force returns an error requiring --force\n- [ ] tick remove --force without an ID returns usage error\n- [ ] tick remove tick-nonexist --force returns \"task 'tick-nonexist' not found\"\n- [ ] The remove subcommand is dispatched correctly from App.Run\n\n## Tests\n\n- \"it removes a single task from JSONL when --force is provided\"\n- \"it matches task ID case-insensitively\"\n- \"it cleans up BlockedBy references on surviving tasks\"\n- \"it reports dependency-updated tasks in RemovalResult\"\n- \"it outputs removal through formatter when not quiet\"\n- \"it suppresses output with --quiet flag\"\n- \"it errors when --force is not provided\"\n- \"it errors when no task ID is provided\"\n- \"it errors when task ID is not found\"\n- \"it dispatches remove command through App.Run\"\n- \"it does not modify other tasks when removing one\"\n\n## Edge Cases\n\n- Case-insensitive ID matching: User may type TICK-ABC123 or Tick-Abc123. Handler normalizes via task.NormalizeID() before searching, consistent with RunTransition. Comparison inside Mutate uses task.NormalizeID() on both sides.\n- Multiple tasks with BlockedBy referencing removed task: When multiple surviving tasks reference the removed task, all must be cleaned up in a single Mutate call.\n\n## Context\n\nFrom the specification: True deletion. The task is filtered from the in-memory slice inside Store.Mutate(), and the JSONL file is rewritten without it. The SQLite cache is rebuilt from JSONL after each write, so the task disappears from both stores atomically.\n\nDependency cleanup: Inside the Mutate callback, after filtering out the removed task(s), iterate remaining tasks and strip all removed IDs from their BlockedBy arrays.\n\nThe --force flag skips interactive confirmation. The RemovalResult struct and FormatRemoval method on the Formatter interface are added by task-removal-1-1 (prerequisite). RemovalResult contains Removed []RemovedTask and DepsUpdated []string. RemovedTask has ID and Title fields.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:15:57Z","updated":"2026-02-19T13:49:10Z","closed":"2026-02-19T13:49:10Z"}
{"id":"tick-0607a0","title":"Handle remove error cases","status":"done","priority":1,"description":"## Problem\n\nTask 1-2 defines error handling in RunRemove but the no-args error message includes a --force suffix that deviates from the spec-mandated message. The spec explicitly states this message should be consistent with existing commands like start, done, cancel, which do not include flags in their usage hint. This task ensures all error messages match the specification exactly and are verified through dedicated tests at the App.Run integration level.\n\n## Solution\n\nCorrect the no-args error message in parseRemoveArgs (or RunRemove) to match the spec exactly, and add focused tests that assert the precise error message text for all error paths: no arguments, task not found, and missing --force. Tests verify both the exact error string and the App.Run-level behavior (stderr output, exit code 1).\n\n## Outcome\n\nAll remove error messages match the specification word-for-word. Dedicated tests assert exact error text (not just substring containment) for the no-args case, ensuring future changes cannot silently drift from the spec.\n\n## Do\n\n1. In internal/cli/remove.go, change the no-ID error message from \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...] --force\" to \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" to match the spec exactly.\n2. Add tests in internal/cli/remove_test.go that verify error cases through App.Run integration:\n   - No arguments: assert stderr contains exactly \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" and exit code is 1.\n   - Task not found: assert stderr contains \"task 'tick-nonexist' not found\" and exit code is 1.\n   - Missing --force: assert stderr contains \"remove requires --force flag\" and exit code is 1.\n3. Verify that the \"Error: \" prefix is applied by App.Run -- tests at the App level should check for \"Error: task ID is required...\" in stderr.\n\n## Acceptance Criteria\n\n- [ ] No-args error message is exactly \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" (no --force suffix)\n- [ ] Not-found error message is \"task '\u003cid\u003e' not found\" using the normalized ID\n- [ ] Missing --force error message communicates that --force is required\n- [ ] All three error cases produce exit code 1 when run through App.Run\n- [ ] All three error cases write the error to stderr (prefixed with \"Error: \" by App.Run)\n- [ ] All existing tests continue to pass\n\n## Tests\n\n- \"it returns exact spec-mandated message when no arguments provided\"\n- \"it returns not-found error for nonexistent task ID\"\n- \"it returns error when --force flag is missing\"\n- \"it returns exact spec-mandated message when only --force provided without ID\"\n\n## Edge Cases\n\n- No-args message must match the spec exactly: \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" -- consistent with start, done, cancel which omit flags from their usage hints.\n- tick remove --force (flag but no positional ID): --force is consumed as a flag, no positional arg remains, so the no-ID error triggers.\n\n## Context\n\nFrom the specification: \"If no task IDs are provided, the command returns an error: 'task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]'. Consistent with existing commands like start, done, cancel.\"\n\nExisting pattern from internal/cli/transition.go: return fmt.Errorf(\"task ID is required. Usage: tick %s \u003cid\u003e\", command) -- no flags in the usage hint.\n\nFrom internal/cli/app.go: all handler errors are printed as \"Error: %s\" to stderr and return exit code 1.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:24:25Z","updated":"2026-02-19T13:53:22Z","closed":"2026-02-19T13:53:22Z"}
{"id":"tick-1777bc","title":"Register remove command help text","status":"done","priority":1,"description":"**Problem**: The remove command needs a help entry in the commands registry in internal/cli/help.go so that tick help, tick help remove, tick help --all, and tick remove --help all display correct usage, description, and flags.\n\n**Solution**: Add a commandInfo entry for remove to the commands slice in help.go. The entry includes the command name, one-line summary, usage string, multi-line description (covering cascade behavior and Git recovery), and the --force / -f flag. The existing help infrastructure renders it automatically.\n\n**Outcome**: tick help lists remove alongside all other commands. tick help remove prints detailed usage including the --force flag, cascade deletion note, and Git recovery guidance. tick help --all includes the remove entry.\n\n**Do**:\n1. In internal/cli/help.go, add a new commandInfo entry to the commands slice after reopen, before dep:\n   - Name: \"remove\"\n   - Summary: \"Permanently remove tasks from the project\"\n   - Usage: \"tick remove \u003cid\u003e [\u003cid\u003e...] [flags]\"\n   - Description: covers permanent deletion from JSONL, cascade to descendants, dep cleanup on survivors, Git recovery\n   - Flags: --force / -f with description \"Skip confirmation prompt\"\n2. In internal/cli/help_test.go, update \"tick help shows all commands\" test to include \"remove\"\n3. Add subtests: \"tick help remove shows flags\", \"tick help remove mentions cascade\", \"tick help remove mentions git recovery\"\n\n**Acceptance Criteria**:\n- [ ] commands slice contains commandInfo with Name: \"remove\"\n- [ ] Remove entry has Usage showing \u003cid\u003e [\u003cid\u003e...]\n- [ ] Remove entry has Flags with --force / -f\n- [ ] Remove entry Description mentions cascade deletion\n- [ ] Remove entry Description mentions Git history as recovery\n- [ ] tick help output includes remove\n- [ ] tick help remove output includes --force flag\n- [ ] tick help --all includes remove\n- [ ] All existing help tests pass\n\n**Tests**:\n- \"tick help shows all commands\" — updated to expect remove\n- \"tick help remove shows flags\" — verifies --force appears\n- \"tick help remove mentions cascade\" — verifies cascade/descendants mentioned\n- \"tick help remove mentions git recovery\" — verifies Git recovery referenced\n\n**Context**:\nFrom the specification: \"The remove command's help entry should document: Usage and flags, Cascade behavior (removing a parent removes all descendants), That Git history serves as the recovery mechanism for accidental removals.\"\n\nThe commands slice in help.go is the single registry — adding an entry makes the command visible everywhere automatically.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:28:14Z","updated":"2026-02-19T13:56:51Z","closed":"2026-02-19T13:56:51Z"}
{"id":"tick-fca658","title":"Phase 2: Interactive Confirmation Prompt","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T11:50:21Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-8bc489","title":"Add Stdin to App and thread through remove handler","status":"done","priority":2,"description":"Problem: The App struct has no Stdin field. The upcoming confirmation prompt needs to read user input from stdin, but RunRemove currently accepts only (dir, fc, fmtr, args, stdout) -- there is no io.Reader parameter for stdin. Without injectable stdin, the confirmation prompt cannot be tested in isolation.\n\nSolution: Add a Stdin io.Reader field to the App struct in internal/cli/app.go. Inject os.Stdin in cmd/tick/main.go. Extend RunRemove's signature to accept an io.Reader parameter for stdin. Update handleRemove to pass a.Stdin through. Remove the hard error on missing --force (replacing it with a placeholder that the next task will fill in). Update all existing test helpers that construct App{} to include the new Stdin field.\n\nOutcome: App has an injectable Stdin io.Reader field. RunRemove receives stdin as a parameter. Production code passes os.Stdin. Tests pass a bytes.Buffer or strings.NewReader. The --force path continues to work unchanged. Without --force, RunRemove no longer errors with \"not yet implemented\" -- instead it accepts the io.Reader argument (the actual prompt logic is deferred to task-removal-2-2).\n\nDo:\n1. In internal/cli/app.go, add Stdin io.Reader field to the App struct with comment: \"Stdin is the standard input reader. Injected for testability (confirmation prompts).\"\n2. In cmd/tick/main.go, set Stdin: os.Stdin in the App struct literal.\n3. In internal/cli/remove.go, change RunRemove signature to include stdin io.Reader parameter (placed before stdout io.Writer).\n4. In RunRemove, remove the hard error for missing --force. When force is false, proceed without error. Add a TODO comment for task-removal-2-2 to add the confirmation prompt.\n5. In internal/cli/app.go, update handleRemove to pass a.Stdin to RunRemove.\n6. Update all test call sites in remove_test.go that call RunRemove directly to pass a stdin argument (e.g., strings.NewReader(\"\")). Update App{} struct literals in remove tests to include Stdin.\n7. Replace the test asserting \"remove requires --force flag\" error with a test verifying RunRemove succeeds without --force.\n8. Existing non-remove test files need no changes -- nil Stdin is safe for all other commands.\n\nAcceptance Criteria:\n- [ ] App struct in internal/cli/app.go has Stdin io.Reader field\n- [ ] cmd/tick/main.go sets Stdin: os.Stdin on the App struct\n- [ ] RunRemove signature includes stdin io.Reader parameter\n- [ ] handleRemove passes a.Stdin to RunRemove\n- [ ] RunRemove does not error when --force is omitted\n- [ ] tick remove \u003cid\u003e --force continues to work exactly as before\n- [ ] All existing tests pass (no regressions)\n- [ ] Remove tests construct App{} with Stdin populated\n\nTests:\n- \"it includes Stdin field on App struct and threads to RunRemove\"\n- \"it does not error when --force is omitted\"\n- \"it preserves --force removal behavior from Phase 1\"\n- \"it passes nil stdin safely for non-remove commands\"\n\nContext: From the spec, the user must enter explicit confirmation to proceed (case-insensitive y or yes). This requires reading from stdin, motivating the Stdin field. The confirmation prompt is written to stderr (Stderr already exists on App). The existing DI pattern (Stdout, Stderr, Getwd, IsTTY) establishes the convention. RunRemove is the first command requiring user input, hence the unique stdin parameter.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-64566b"],"parent":"tick-fca658","created":"2026-02-19T11:50:30Z","updated":"2026-02-19T14:01:25Z","closed":"2026-02-19T14:01:25Z"}
{"id":"tick-0c56d2","title":"Implement confirmation prompt with accept and abort paths","status":"done","priority":2,"description":"Problem: When --force is not provided, RunRemove currently proceeds without any confirmation gate (after task-removal-2-1 replaced the hard error with a placeholder). The specification requires an interactive confirmation prompt before removal -- the user must explicitly type y or yes to proceed. Without this gate, accidental removal of tasks has no safety net. The prompt text and abort message must go to stderr (keeping stdout clean for piped usage), and abort must exit with code 1.\n\nSolution: Add a stderr io.Writer parameter to RunRemove and thread a.Stderr from handleRemove. When --force is false, write a confirmation prompt to stderr showing the task ID and title with [y/N] convention, read one line from stdin via bufio.NewReader, trim whitespace, compare case-insensitively against y/yes. On acceptance, proceed with removal. On any other input (including empty Enter), write \"Aborted.\" to stderr and return a sentinel error that App.Run translates to exit code 1 without the standard \"Error: \" prefix.\n\nOutcome: Running tick remove \u003cid\u003e without --force displays a confirmation prompt on stderr, reads input from stdin, and either proceeds with removal (on y/yes) or aborts with \"Aborted.\" on stderr and exit code 1. The --force flag continues to skip the prompt entirely.\n\nDo:\n1. In internal/cli/remove.go, add a stderr io.Writer parameter to RunRemove after stdin io.Reader. New signature: RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdin io.Reader, stderr io.Writer, stdout io.Writer) error.\n2. Define a sentinel error in internal/cli/remove.go: var errAborted = errors.New(\"aborted\"). This distinguishes user-declined aborts from real errors.\n3. In RunRemove, replace the TODO placeholder for the non-force path with confirmation logic:\n   - Look up the target task to get its title before prompting.\n   - Write the prompt to stderr: fmt.Fprintf(stderr, \"Remove task %s \\\"%s\\\"? [y/N] \", id, title).\n   - Read one line from stdin using bufio.NewReader(stdin).ReadString('\\n').\n   - Trim with strings.TrimSpace and lowercase with strings.ToLower.\n   - If normalized response is \"y\" or \"yes\", proceed with removal.\n   - Otherwise, write fmt.Fprintln(stderr, \"Aborted.\") and return errAborted.\n4. In internal/cli/app.go, update handleRemove to pass a.Stderr to RunRemove.\n5. In internal/cli/app.go, update the error handling block after the command switch to detect errAborted: if errors.Is(err, errAborted) { return 1 } before the \"Error: \" prefix logic.\n6. Update all test call sites in remove_test.go that call RunRemove directly to include the new stderr parameter (pass a \u0026bytes.Buffer{}).\n7. Add tests for confirmation prompt behavior.\n\nAcceptance Criteria:\n- [ ] Without --force, RunRemove writes prompt \"Remove task \u003cid\u003e \\\"\u003ctitle\u003e\\\"? [y/N] \" to stderr\n- [ ] Entering y (lowercase) proceeds with removal and outputs result to stdout\n- [ ] Entering Y (uppercase) proceeds with removal\n- [ ] Entering yes/YES/yEs (case-insensitive) proceeds with removal\n- [ ] Empty Enter writes \"Aborted.\" to stderr and returns exit code 1\n- [ ] Entering n, no, maybe, or any non-y/yes input writes \"Aborted.\" to stderr and returns exit code 1\n- [ ] Whitespace-padded input (\"  y  \") proceeds with removal after trimming\n- [ ] Prompt text and \"Aborted.\" message are written to stderr, not stdout\n- [ ] Stdout remains empty on abort\n- [ ] --force continues to skip the prompt entirely\n- [ ] App.Run returns exit code 1 on abort without printing \"Error: \" prefix\n- [ ] All existing tests continue to pass\n\nTests:\n- \"it prompts for confirmation on stderr when --force is not provided\"\n- \"it proceeds with removal when user enters y\"\n- \"it proceeds with removal when user enters Y (uppercase)\"\n- \"it proceeds with removal when user enters yes\"\n- \"it proceeds with removal when user enters YES (case-insensitive)\"\n- \"it aborts when user presses Enter (empty input)\"\n- \"it aborts when user enters n\"\n- \"it aborts when user enters arbitrary text\"\n- \"it trims whitespace from user input before comparing\"\n- \"it writes Aborted message to stderr on decline\"\n- \"it does not write to stdout on abort\"\n- \"it skips prompt entirely when --force is provided\"\n- \"it returns exit code 1 on abort without Error prefix via App.Run\"\n\nEdge Cases:\n- Case-insensitive y/yes: strings.ToLower(strings.TrimSpace(input)) handles all combinations\n- Empty Enter aborts: ReadString returns newline, TrimSpace becomes empty string\n- Whitespace-padded input: trimmed before comparison\n- EOF on stdin: treat as abort\n- errAborted sentinel: must not leak through App.Run's Error prefix\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-fca658","created":"2026-02-19T11:54:14Z","updated":"2026-02-19T14:12:55Z","closed":"2026-02-19T14:12:55Z"}
{"id":"tick-192a68","title":"Phase 3: Cascade Deletion, Dependency Cleanup, and Bulk Removal","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T12:01:56Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-2a1fa5","title":"Bulk argument parsing with deduplication","status":"done","priority":2,"description":"Problem: parseRemoveArgs currently returns a single task ID (id string). The specification requires tick remove \u003cid\u003e [\u003cid\u003e...] supporting multiple positional arguments. Before cascade, validation, or the confirmation prompt can work with multiple targets, the argument parsing layer must collect all positional IDs, deduplicate them, and return them as a slice.\n\nSolution: Refactor parseRemoveArgs in internal/cli/remove.go to return a slice of deduplicated, normalized task IDs instead of a single ID. The function iterates args, skips --force/-f flags (and any unknown flags starting with -), collects all other positional arguments as task IDs, normalizes each via task.NormalizeID, deduplicates using a seen-set, and preserves the first-occurrence order. Update RunRemove and all existing call sites/tests to use the new return type.\n\nOutcome: parseRemoveArgs returns (ids []string, force bool, err error) where ids is a deduplicated, normalized slice of task IDs. All existing single-ID tests pass without behavioral change.\n\nDo:\n1. In internal/cli/remove.go, change parseRemoveArgs signature from (args []string) (id string, force bool, err error) to (args []string) (ids []string, force bool, err error).\n2. Replace single-ID extraction with loop: iterate args, --force/-f sets force, - prefix skips, otherwise normalize via task.NormalizeID and append to candidates. Deduplicate with map[string]bool preserving first-occurrence order.\n3. Update RunRemove: change no-ID check from if id == \"\" to if len(ids) == 0. For Mutate callback and confirmation prompt, continue using ids[0] as single target (tasks 3-2 through 3-5 extend to full slice).\n4. Update all existing tests to destructure new return type (ids, force, err) and assert ids[0].\n5. Add new TestParseRemoveArgs subtests for bulk and deduplication scenarios.\n\nAcceptance Criteria:\n- [ ] parseRemoveArgs returns ([]string, bool, error) instead of (string, bool, error)\n- [ ] Single ID input returns slice of length 1 with normalized ID\n- [ ] Multiple IDs return all IDs in order, normalized\n- [ ] Duplicate IDs silently deduplicated, preserving first-occurrence order\n- [ ] Case-variant duplicates (TICK-AAA and tick-aaa) treated as same ID and deduplicated\n- [ ] --force and -f extracted regardless of position among IDs\n- [ ] Unknown flags skipped without error\n- [ ] No positional arguments returns empty slice\n- [ ] All existing single-ID removal tests pass\n- [ ] RunRemove works with refactored return type\n\nTests:\n- parseRemoveArgs returns single ID as slice of length 1\n- parseRemoveArgs returns multiple IDs in order\n- parseRemoveArgs normalizes IDs to lowercase\n- parseRemoveArgs deduplicates identical IDs\n- parseRemoveArgs deduplicates case-variant IDs\n- parseRemoveArgs preserves first-occurrence order after dedup\n- parseRemoveArgs extracts --force from between IDs\n- parseRemoveArgs extracts -f shorthand flag\n- parseRemoveArgs handles --force before and after all IDs\n- parseRemoveArgs skips unknown flags mixed with IDs\n- parseRemoveArgs returns empty slice when only flags or no args provided\n- RunRemove still removes single task with refactored parseRemoveArgs\n\nEdge Cases:\n- Duplicate IDs silently deduplicated: tick remove tick-aaa tick-aaa --force produces ids=[\"tick-aaa\"]\n- Case-variant duplicates: tick remove TICK-AAA tick-aaa deduplicates to [\"tick-aaa\"]\n- Single ID still works: ids[0] used where id was previously\n- Mixed flags and positional args: --unknown silently skipped\n- --force only (no IDs): returns ids=[] and force=true, RunRemove returns usage error\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-64566b"],"parent":"tick-192a68","created":"2026-02-19T12:02:08Z","updated":"2026-02-19T14:17:15Z","closed":"2026-02-19T14:17:15Z"}
{"id":"tick-37bab0","title":"All-or-nothing ID validation for bulk removal","status":"done","priority":2,"description":"## Problem\n\nRunRemove currently validates a single task ID inside the Store.Mutate callback by searching for it in the task slice and returning \"task '%s' not found\" if absent. After task-removal-3-1, parseRemoveArgs returns a []string of deduplicated IDs, but RunRemove still uses only ids[0]. When bulk removal is introduced, if validation happens per-task during filtering, the first valid task could be removed before the second invalid task triggers an error -- violating the all-or-nothing guarantee.\n\n## Solution\n\nAdd a validation step at the top of the Store.Mutate callback that builds a lookup set from the task slice and checks every ID. If any is missing, return an error immediately before any filtering. Replace single-task filtering with removeSet map for O(1) lookup. Extend dep cleanup to strip all removed IDs.\n\n## Outcome\n\nWhen any ID in a bulk tick remove invocation does not exist, the command fails with \"task '\u003cid\u003e' not found\" and zero tasks are removed. When all IDs exist, removal proceeds atomically.\n\n## Do\n\n1. In internal/cli/remove.go, inside RunRemove's store.Mutate callback, add validation: build existingIDs map from task slice, iterate ids, error on first missing ID.\n2. Update RunRemove to use full ids slice. Build removeSet map for O(1) filtering. Collect RemovalResult.Removed entries for all validated IDs.\n3. Update dep cleanup loop to strip all IDs in removeSet from surviving tasks' BlockedBy arrays.\n4. For confirmation prompt (non-force): look up each ID's title and prompt with the full set.\n5. Add tests for validation edge cases.\n\n## Acceptance Criteria\n\n- [ ] When all provided IDs exist, all corresponding tasks are removed in a single Mutate call\n- [ ] When first ID valid but second invalid, zero tasks removed, error reports invalid ID\n- [ ] When all IDs invalid, zero tasks removed, error reports first invalid ID\n- [ ] Error message format is \"task '\u003cid\u003e' not found\" using normalized ID\n- [ ] Dependency cleanup handles all removed IDs, not just one\n- [ ] Single-ID removal continues to work identically\n- [ ] JSONL file unchanged when validation fails\n- [ ] All existing remove tests pass\n\n## Tests\n\n- \"it removes multiple tasks when all IDs are valid\"\n- \"it fails with not-found error when first ID is valid but second is invalid\"\n- \"it fails with not-found error when all IDs are invalid\"\n- \"it removes zero tasks when any ID is invalid (all-or-nothing)\"\n- \"it reports the first invalid ID in the error message\"\n- \"it cleans up BlockedBy references for all removed task IDs\"\n- \"it preserves single-ID removal behavior\"\n- \"it does not modify JSONL when validation fails\"\n\n## Edge Cases\n\n- First ID valid, second invalid: first missing ID triggers error, no tasks removed\n- All IDs invalid: first ID in ids slice triggers error immediately\n- Duplicate IDs after dedup: already handled by task-removal-3-1\n- Single ID not found: existing behavior preserved\n\n## Context\n\nFrom the spec: \"If any provided task ID does not exist, the command fails with an error before any removal occurs. No partial removal -- either all targets are valid and removed, or none are.\"\n\nValidation occurs inside Store.Mutate which holds exclusive file lock. Returning error causes Store.Mutate to skip JSONL write entirely, guaranteeing atomicity. The ids slice is already deduplicated and normalized by parseRemoveArgs (task-removal-3-1).\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:05:39Z","updated":"2026-02-19T14:23:46Z","closed":"2026-02-19T14:23:46Z"}
{"id":"tick-5b74ec","title":"Cascade descendant collection","status":"done","priority":2,"description":"Problem: When a parent task is removed, all its descendants (children, grandchildren, etc.) must also be removed. The removal flow operates inside Store.Mutate() on an in-memory []task.Task slice, where SQLite is not available. There is no in-memory function to recursively collect all descendants of a given set of task IDs from a task slice.\n\nSolution: Implement a standalone collectDescendants function in internal/cli/remove.go that takes a set of target IDs and the full []task.Task slice, then returns the complete set of IDs to remove (targets + all recursive descendants). Builds a parent-to-children index, walks recursively for each target. Pure function, independently testable.\n\nOutcome: A tested collectDescendants function exists that, given target IDs and a task slice, returns the deduplicated union of those targets plus all their transitive descendants. Task 3-4 will call this function inside the Mutate callback.\n\nDo:\n1. In internal/cli/remove.go, add collectDescendants(targetIDs map[string]bool, tasks []task.Task) map[string]bool:\n   - Build childrenOf map (map[string][]string) by iterating tasks, grouping by task.NormalizeID(t.Parent) where Parent is non-empty\n   - Start with result set initialized from targetIDs\n   - For each target ID, recursively walk childrenOf to collect all descendant IDs\n   - Return combined set (targets + descendants)\n2. In internal/cli/remove_test.go, add TestCollectDescendants with subtests.\n\nAcceptance Criteria:\n- [ ] collectDescendants returns only target IDs when none have children\n- [ ] collectDescendants returns target + direct children when target has children\n- [ ] collectDescendants returns target + all transitive descendants for 3+ level hierarchies\n- [ ] Removing a child does not cascade upward -- parent and siblings not included\n- [ ] Descendants already in target set are not duplicated\n- [ ] Multiple targets with overlapping subtrees: descendant appears once\n- [ ] Empty targetIDs input returns empty result set\n- [ ] Tasks with no Parent field never collected as descendants\n- [ ] ID comparison uses task.NormalizeID for case-insensitive matching\n\nTests:\n- \"target with no children returns only target\"\n- \"target with direct children collects them\"\n- \"deep hierarchy collects all levels\" (A -\u003e B -\u003e C -\u003e D)\n- \"child removal does not cascade upward\" (targeting B in A-\u003eB-\u003eC returns {B,C} not {A,B,C})\n- \"target already includes descendant deduplicates\"\n- \"multiple targets with overlapping descendants\"\n- \"empty target set returns empty result\"\n- \"case-insensitive ID matching\"\n\nEdge Cases:\n- Deep hierarchy (3+ levels): recursive walk must not stop at direct children\n- Task with no children: returns only original targets, no nil-map issues\n- Child removal does not cascade upward: walks Parent-\u003eChildren direction only\n- Mixed-case IDs: task.NormalizeID applied consistently\n\nContext:\nFrom the spec: \"When a task with children is removed, all descendants are collected recursively.\" The existing queryDescendantIDs in list.go uses SQLite recursive CTE but the removal flow needs an in-memory equivalent inside the Mutate callback. Task.Parent field is the only relationship link. Function signature uses map[string]bool consistent with removeSet from task 3-2.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:13:40Z","updated":"2026-02-19T14:28:03Z","closed":"2026-02-19T14:28:03Z"}
{"id":"tick-9e0c27","title":"Integrate cascade into removal flow with confirmation prompt","status":"done","priority":2,"description":"## Problem\n\nAfter tasks 3-2 and 3-3, RunRemove can validate and remove multiple IDs atomically with dependency cleanup, and collectDescendants can compute the full set of transitive descendants. However, collectDescendants is not called anywhere in the removal flow. Parent tasks are removed without their descendants, leaving orphaned children. The confirmation prompt only shows explicitly targeted tasks, not the cascade blast radius.\n\n## Solution\n\nWire collectDescendants into the RunRemove flow. After all-or-nothing ID validation but before filtering, call collectDescendants(removeSet, tasks) to expand the remove set with all transitive descendants. Update the confirmation prompt (non-force path) to show the full blast radius: explicitly targeted tasks plus cascaded descendants. Ensure dependency cleanup iterates the expanded remove set. With --force, cascade proceeds silently.\n\n## Outcome\n\nRunning tick remove \u003cparent-id\u003e removes the parent and all descendants atomically. The confirmation prompt (without --force) lists all tasks that will be removed, distinguishing targets from descendants. Dependency cleanup scrubs all removed IDs from surviving tasks' BlockedBy arrays. --force skips the prompt but still cascades.\n\n## Do\n\n1. In internal/cli/remove.go, inside RunRemove, after the all-or-nothing ID validation loop and before the confirmation prompt / filtering logic, call collectDescendants(removeSet, tasks) and reassign the result to removeSet.\n\n2. Update the pre-prompt task lookup to collect information for all IDs in the expanded removeSet. Build three collections:\n   - targetTasks: tasks explicitly passed as arguments (original ids slice)\n   - cascadedTasks: tasks added by collectDescendants (in removeSet but not in original ids set)\n   - affectedDepTasks: surviving tasks (not in removeSet) that have any removeSet ID in their BlockedBy arrays — these will have dependency references cleaned up\n\n3. Update the confirmation prompt logic (non-force path) to display the full blast radius on stderr:\n   - Single target, no cascade, no dep impact: keep existing format -- Remove task tick-abc \"Title\"? [y/N]\n   - When cascade applies: show target, list cascaded descendants\n   - When surviving tasks have dependency references: list which surviving tasks will have dependency references cleaned (e.g., \"Will update dependencies on tick-def, tick-ghi\")\n   - Multiple targets: list all targets, then additional cascaded descendants, then affected dependencies\n   Prompt must surface every task that will be removed, distinguish descendants from explicit targets, and show which surviving tasks will have dependency references cleaned.\n\n4. Ensure filtering step uses expanded removeSet for keeping/removing tasks, recording RemovalResult.Removed, and stripping from surviving tasks' BlockedBy arrays.\n\n5. In internal/cli/remove_test.go, add tests for cascade integration.\n\n## Acceptance Criteria\n\n- [ ] Removing a parent task also removes all transitive descendants in a single Store.Mutate call\n- [ ] Removing a leaf (child) task does not remove its parent or siblings\n- [ ] Confirmation prompt (without --force) lists all tasks including cascaded descendants\n- [ ] Prompt distinguishes explicitly targeted tasks from cascaded descendants\n- [ ] Confirmation prompt (without --force) lists surviving tasks whose dependency references will be cleaned\n- [ ] --force with cascade proceeds silently without any prompt\n- [ ] RemovalResult.Removed includes targets and all cascaded descendants\n- [ ] Dependency cleanup scrubs all removed IDs (targets + descendants) from surviving tasks' BlockedBy\n- [ ] RemovalResult.DepsUpdated reflects tasks whose BlockedBy was cleaned of any expanded-set ID\n- [ ] Prompt text and abort message written to stderr\n- [ ] Single target with no children and no dep impact retains existing simple prompt format\n- [ ] All existing remove tests continue to pass\n\n## Tests\n\n- \"it removes parent and all descendants when removing a parent with --force\"\n- \"it removes 3-level hierarchy (parent -\u003e child -\u003e grandchild) with --force\"\n- \"it does not remove parent when removing a child with --force\"\n- \"it does not remove siblings when removing a child with --force\"\n- \"it shows descendants in confirmation prompt when removing parent without --force\"\n- \"it shows affected dependency tasks in confirmation prompt\"\n- \"it proceeds with cascade removal when user confirms with y\"\n- \"it aborts cascade removal when user declines\"\n- \"it skips prompt entirely with --force for cascade removal\"\n- \"it cleans BlockedBy references for all cascaded descendant IDs on surviving tasks\"\n- \"it reports all cascade-removed tasks in RemovalResult.Removed\"\n- \"it reports dep-updated tasks in RemovalResult.DepsUpdated for cascade-removed IDs\"\n- \"it retains simple prompt format for single target with no children and no dep impact\"\n- \"it writes cascade prompt to stderr not stdout\"\n\n## Edge Cases\n\n- Cascade with --force skips prompt: collectDescendants expands set, filtering proceeds, no stdin/stderr interaction\n- Prompt lists all cascaded descendants: user must see every task before confirming\n- Dependency cleanup covers all removed IDs: surviving task blocked by both parent and grandchild must have both stripped\n- Single target with no children and no dep impact: prompt remains Phase 2 format, no noise\n- Removing a child does not cascade upward: only child and its own descendants removed\n\n## Context\n\nFrom the spec: \"When a task with children is removed, all descendants are collected recursively. All collected tasks are removed in a single atomic Store.Mutate() call. Dependency references for all removed tasks are auto-cleaned from surviving tasks.\"\n\nConfirmation prompt: \"Explicitly lists all tasks that will be removed.\" The prompt surfaces blast radius including dependency references that will be cleaned from surviving tasks. With --force: \"Cascade proceeds silently.\"\n\ncollectDescendants (task 3-3) takes targetIDs map[string]bool and tasks []task.Task, returns map[string]bool. removeSet (task 3-2) is the input; returned map replaces it.\n\nRemovalResult (task 1-1) has Removed []RemovedTask and DepsUpdated []string. Both must reflect the expanded set.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-0c56d2"],"parent":"tick-192a68","created":"2026-02-19T12:18:05Z","updated":"2026-02-19T14:38:18Z","closed":"2026-02-19T14:38:18Z"}
{"id":"tick-0424d3","title":"Bulk and cascade interaction with cross-target deduplication","status":"done","priority":2,"description":"## Problem\n\nAfter tasks 3-1 through 3-4, RunRemove supports bulk IDs, all-or-nothing validation, cascade descendant collection, and an expanded confirmation prompt. However, no tests verify the interaction between bulk removal and cascade when they combine. Three untested scenarios: (1) task is both explicit arg and cascaded descendant, (2) two targets where one is ancestor of the other, (3) bulk leaf removal with no cascade.\n\n## Solution\n\nAdd focused integration tests in internal/cli/remove_test.go exercising combined bulk + cascade paths through RunRemove. Fix any discovered bugs.\n\n## Outcome\n\nAll interaction scenarios covered by passing tests. Explicit-arg-plus-cascade overlap handled silently, shared descendants deduplicated, bulk leaf removal works without cascade side effects. Any discovered bugs fixed.\n\n## Do\n\n1. In internal/cli/remove_test.go, add TestBulkCascadeInteraction test group.\n\n2. Subtest: \"explicit arg that is also a cascaded descendant is removed once\" -- Create A -\u003e B -\u003e C, plus unrelated D. RunRemove with [A, B, --force]. Assert: A, B, C removed, D survives. RemovalResult.Removed has 3 entries, no duplicates.\n\n3. Subtest: \"two targets where one is ancestor of the other\" -- Create A -\u003e B -\u003e C. RunRemove with [A, C, --force]. All three removed once. RemovalResult.Removed has 3 entries.\n\n4. Subtest: \"bulk removal of unrelated leaf tasks\" -- Create A, B, C, D (all leaves). RunRemove with [A, C, --force]. A and C removed, B and D survive. RemovalResult.Removed has 2 entries.\n\n5. Subtest: \"dependency cleanup covers all expanded cascade IDs\" -- Create Parent -\u003e Child1, Parent -\u003e Child2. Create Survivor with BlockedBy: [Child1, Child2]. RunRemove with [Parent, --force]. All three removed. Survivor's BlockedBy empty. DepsUpdated includes Survivor.\n\n6. Subtest: \"confirmation prompt shows deduplicated blast radius for bulk+cascade\" -- Create A -\u003e B -\u003e C, plus leaf D. RunRemove with [A, B, D] (no --force), stdin \"y\\n\". Assert stderr mentions A, B, C, D. B not listed twice. All four removed.\n\n7. Subtest: \"confirmation prompt abort prevents any removal for bulk+cascade\" -- Create A -\u003e B, C (leaf). RunRemove with [A, C] (no --force), stdin \"n\\n\". All tasks survive. stderr contains \"Aborted.\"\n\n## Acceptance Criteria\n\n- [ ] Task appearing as both explicit argument and cascaded descendant is removed exactly once\n- [ ] When one explicit target is ancestor of another, cascade deduplicates\n- [ ] Bulk removal of unrelated leaf tasks removes exactly those tasks\n- [ ] Dependency cleanup scrubs all expanded cascade IDs from surviving BlockedBy\n- [ ] Confirmation prompt displays full deduplicated set for bulk+cascade\n- [ ] Declining confirmation aborts without removing any tasks\n- [ ] No duplicate entries in RemovalResult.Removed\n- [ ] All existing remove tests pass\n\n## Tests\n\n- \"explicit arg that is also a cascaded descendant is removed once\"\n- \"two targets where one is ancestor of the other\"\n- \"bulk removal of unrelated leaf tasks\"\n- \"dependency cleanup covers all expanded cascade IDs\"\n- \"confirmation prompt shows deduplicated blast radius for bulk+cascade\"\n- \"confirmation prompt abort prevents any removal for bulk+cascade\"\n\n## Edge Cases\n\n- Explicit + cascade overlap: map[string]bool naturally deduplicates. RemovalResult.Removed collection must not double-count.\n- Ancestor/descendant targets: collectDescendants walks from each target, merges into same map.\n- Leaf bulk: collectDescendants returns input unchanged. Verifies no spurious cascade.\n- Dep cleanup for expanded set: surviving task referencing multiple removed IDs must have all scrubbed.\n\n## Context\n\nFrom the spec: \"Deduplication also applies when a task appears both as an explicit argument and as a cascaded descendant -- it is only removed once.\" and \"Bulk + cascade interaction: all targets plus descendants collected, deduplicated, removed atomically.\"\n\nImplementation uses map[string]bool throughout (removeSet, collectDescendants output), so deduplication is inherent. These tests verify end-to-end behavior through RunRemove.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:22:35Z","updated":"2026-02-19T14:42:52Z","closed":"2026-02-19T14:42:52Z"}
{"id":"tick-d5946b","title":"Phase 4: Analysis (cycle 1)","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T14:59:09Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-cf66a9","title":"Consolidate blast radius computation into Mutate callback","status":"done","priority":2,"description":"severity: high\nsources: duplication, architecture\n\n**Problem**: `computeBlastRadius` (lines 58-141) and the `Mutate` callback in `RunRemove` (lines 172-223) both independently (1) validate all IDs exist with all-or-nothing semantics, (2) build a removeSet from explicit targets, and (3) expand that set with transitive descendants. The blast radius function does this via SQL queries with an iterative fixed-point loop; the Mutate callback does it via the in-memory task slice using `collectDescendants`. This creates ~30 lines of duplicated logic, a maintenance burden (changes must be synced across both paths), a theoretical TOCTOU gap between the Query read and the Mutate write, a duplicate type (`idTitle` in remove.go mirrors `RemovedTask` in format.go), and a non-standard inline interface parameter on `computeBlastRadius`.\n\n**Solution**: Restructure so the Mutate callback is the single source of truth for validation and descendant expansion. Introduce a \"dry run\" mode: the Mutate callback computes the full blast radius (removed tasks, cascaded descendants, affected deps) and returns it without persisting when a flag indicates dry-run. For the non-force path, call Mutate in dry-run mode to get the blast radius for the confirmation prompt, then call Mutate again for the real removal if the user confirms. For the force path, call Mutate once (real mode). This eliminates `computeBlastRadius` entirely along with its SQL queries, the `idTitle` type (use `RemovedTask` for prompt data too), and the inline interface.\n\n**Outcome**: One code path for validation and descendant expansion. No duplicate types. No inline interface. The confirmation prompt shows data computed by the same algorithm that performs the actual removal. The TOCTOU gap is narrowed to an inherent property of the confirmation pattern rather than being amplified by divergent code paths.\n\n**Do**:\n1. In `internal/cli/remove.go`, replace the `idTitle` type with `RemovedTask` from `format.go` in the `blastRadius` struct fields (`targetTasks`, `cascadedTasks`, `affectedDeps`).\n2. Update `confirmRemovalWithCascade` to accept a `blastRadius` that uses `RemovedTask` fields (access `.ID` and `.Title` instead of `.id` and `.title`).\n3. Refactor the Mutate callback into a named function (e.g., `executeRemoval`) that takes the task slice and target IDs, performs validation, descendant expansion via `collectDescendants`, filtering, and dep cleanup, and returns the filtered slice, a `blastRadius` (populated with `RemovedTask` values), a `RemovalResult`, and an error.\n4. Add a `computeOnly bool` parameter (or split into two functions): when true, the function validates and computes the blast radius but returns the original task slice unmodified; when false, it performs the full removal and returns the filtered slice.\n5. In `RunRemove`, for the non-force path: call `store.Mutate` with `computeOnly=true` to get the blast radius, show the confirmation prompt, then call `store.Mutate` again with `computeOnly=false` to perform the removal. For the force path: call `store.Mutate` once with `computeOnly=false`.\n6. Delete the `computeBlastRadius` function, the `idTitle` type, and the `database/sql` import (if no longer needed).\n7. Verify all existing tests pass without modification (the external behavior is unchanged).\n\n**Acceptance Criteria**:\n- `computeBlastRadius` function is removed\n- `idTitle` type is removed\n- No `database/sql` import in `remove.go` unless needed elsewhere\n- ID validation and descendant expansion exist in exactly one code path\n- The confirmation prompt (non-force path) still shows target tasks, cascaded descendants, and affected dependencies\n- All existing tests in `internal/cli` pass unchanged\n- Force and non-force paths produce identical removal results for the same inputs\n\n**Tests**:\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions in other commands\n- Verify force and non-force paths produce same output by comparing formatter output in existing test cases that test both paths","parent":"tick-d5946b","created":"2026-02-19T14:59:38Z","updated":"2026-02-19T15:06:25Z","closed":"2026-02-19T15:06:25Z"}
{"id":"tick-21f1ab","title":"Align RunRemove signature with handler convention","status":"done","priority":2,"description":"severity: medium\nsources: architecture\n\n**Problem**: Every `Run*` handler in the cli package follows the signature pattern `Run*(dir, fc, fmtr, args, stdout)` with 4-5 parameters. `RunRemove` takes 7 parameters (`dir`, `fc`, `fmtr`, `args`, `stdin`, `stderr`, `stdout`), breaking the uniform handler contract. The extra `stdin` and `stderr` parameters are needed for the interactive confirmation prompt but create an inconsistency that makes the handler harder to call and understand at a glance.\n\n**Solution**: Move the confirmation prompt logic into `handleRemove` on the `App` struct (which already has access to `a.Stdin` and `a.Stderr`), and slim `RunRemove` down to the standard 5-parameter signature. `RunRemove` should only handle the mutation and formatting -- not the interactive prompt. The `handleRemove` method computes the blast radius, runs the confirmation prompt using `a.Stdin`/`a.Stderr`, then calls `RunRemove` for the actual removal.\n\n**Outcome**: `RunRemove` conforms to the established `Run*(dir, fc, fmtr, args, stdout)` signature. The interactive prompt concern is separated from the mutation concern. The handler dispatch pattern in `app.go` remains consistent.\n\n**Do**:\n1. In `internal/cli/app.go`, expand `handleRemove` to: parse args (call `parseRemoveArgs`), open the store, compute the blast radius (if not force), run the confirmation prompt using `a.Stdin` and `a.Stderr`, then call `RunRemove`.\n2. Change `RunRemove` signature to `RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdout io.Writer) error` -- matching other handlers. It receives pre-validated IDs (the force flag has already been handled), performs the Mutate, and formats output.\n3. Alternatively, if Task 1 has not been applied yet and `computeBlastRadius` still exists, `handleRemove` calls `computeBlastRadius` + `confirmRemovalWithCascade` before calling `RunRemove`. If Task 1 has been applied, `handleRemove` calls the dry-run Mutate + confirmation before calling `RunRemove` for the real Mutate.\n4. Update all call sites of `RunRemove` (only `handleRemove` in app.go).\n5. Update any tests that call `RunRemove` directly to use the new 5-parameter signature. Tests that need confirmation behavior should test via `App.Run` instead.\n6. Move `confirmRemovalWithCascade` call site to `handleRemove` or keep it in remove.go as a helper but remove `stdin`/`stderr` from `RunRemove`.\n\n**Acceptance Criteria**:\n- `RunRemove` signature matches `Run*(dir, fc, fmtr, args, stdout)` pattern\n- `RunRemove` has no `stdin` or `stderr` parameters\n- Interactive confirmation logic lives in `handleRemove` or a helper called from `handleRemove`\n- All existing tests pass\n- Force and non-force behavior unchanged\n\n**Tests**:\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions\n- Verify `RunRemove` can be called without stdin/stderr in tests that only need mutation behavior","parent":"tick-d5946b","created":"2026-02-19T14:59:59Z","updated":"2026-02-19T15:12:32Z","closed":"2026-02-19T15:12:32Z"}
{"id":"tick-9c6995","title":"Phase 5: Analysis (cycle 2)","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T15:25:47Z","updated":"2026-02-19T15:35:27Z","closed":"2026-02-19T15:35:27Z"}
{"id":"tick-0c7c52","title":"Replace read-only Mutate with Store.ReadTasks and restructure handleRemove into a single-open flow","status":"done","priority":2,"description":"**Problem**: The non-force path in `handleRemove` (app.go:228-247) calls `store.Mutate` with `computeOnly=true` to compute the blast radius for the confirmation prompt. `Store.Mutate` always rewrites the JSONL file and rebuilds the SQLite cache regardless of whether the callback modifies the data (store.go:152-172). This means every non-forced remove rewrites the entire JSONL file unnecessarily before the user even sees the prompt. If the user declines, the file was rewritten for nothing -- and re-marshalling could introduce byte-level differences that change the file's MD5 hash and trigger unnecessary cache rebuilds. After the prompt, `handleRemove` delegates to `RunRemove` which opens the store a second time and runs `executeRemoval` again, creating a TOCTOU gap where another process could modify tasks between confirmation and execution. Additionally, `parseRemoveArgs` and the `len(ids)==0` check run twice (once in `handleRemove`, once in `RunRemove`), and the error message string `\"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\"` is duplicated verbatim. The `executeRemoval` function uses a `computeOnly bool` parameter to serve two fundamentally different purposes (read-only blast radius vs. actual removal), which is a boolean-parameter anti-pattern.\n\n**Solution**: (1) Add a `Store.ReadTasks` method that reads and parses the JSONL file under a shared lock without writing. (2) Split `executeRemoval` into two functions: `computeBlastRadius(tasks, ids)` for read-only blast radius computation and `applyRemoval(tasks, ids)` for the actual mutation. Both share internal helpers (`collectDescendants`, validation, `stripIDsFromBlockedBy`). (3) Restructure `handleRemove` so the non-force path uses `Store.ReadTasks` + `computeBlastRadius` for the prompt, then calls `RunRemove` once for the actual mutation. This eliminates the spurious Mutate rewrite, the double store open, the double executeRemoval, and the boolean parameter.\n\n**Outcome**: Non-forced removes no longer rewrite JSONL for the confirmation prompt. The store opens once for the read-only blast radius check (via `ReadTasks`) and once for the actual mutation (via `RunRemove`). No TOCTOU gap beyond the inherent confirmation pattern. `parseRemoveArgs` and ID validation run once in `handleRemove`, with pre-parsed IDs passed to `RunRemove`. Each function has a single responsibility. The `computeOnly` parameter is eliminated.\n\n**Do**:\n1. In `internal/storage/store.go`, add a `ReadTasks` method:\n   ```go\n   func (s *Store) ReadTasks() ([]task.Task, error) {\n       unlock, err := s.acquireShared()\n       if err \\!= nil {\n           return nil, err\n       }\n       defer unlock()\n       _, tasks, err := s.readAndEnsureFresh()\n       if err \\!= nil {\n           return nil, err\n       }\n       return tasks, nil\n   }\n   ```\n   This provides read-only access to the in-memory task slice without writing.\n2. In `internal/cli/remove.go`, split `executeRemoval` into two functions:\n   - `computeBlastRadius(tasks []task.Task, ids []string) (blastRadius, error)` -- validates all IDs exist, expands descendants via `collectDescendants`, identifies cascaded tasks and affected deps. Returns a populated `blastRadius` struct.\n   - `applyRemoval(tasks []task.Task, ids []string) ([]task.Task, RemovalResult, error)` -- validates all IDs exist, expands descendants, filters removed tasks from the slice, cleans up `BlockedBy` arrays on surviving tasks, returns the filtered slice and `RemovalResult`.\n   - Both functions call shared helpers for validation and descendant expansion. Extract the common ID-validation loop and descendant expansion into a helper like `validateAndExpand(tasks, ids) (targetSet, removeSet, existingIDs map, error)` if the duplication between the two new functions warrants it.\n3. Delete the `executeRemoval` function.\n4. Update `RunRemove` to:\n   - Accept pre-parsed IDs instead of raw args. Change signature to `RunRemove(dir string, fc FormatConfig, fmtr Formatter, ids []string, stdout io.Writer) error`. Remove the `parseRemoveArgs` call and `len(ids)==0` check from `RunRemove` (these now live only in `handleRemove`).\n   - Call `store.Mutate` with `applyRemoval` (no `computeOnly` flag).\n5. Update `handleRemove` in `internal/cli/app.go`:\n   - Parse args once: `ids, force := parseRemoveArgs(subArgs)`. Validate `len(ids)==0` once.\n   - Non-force path: open store via `openStore`, call `store.ReadTasks()` to get the task slice, call `computeBlastRadius(tasks, ids)`, close the store, run `confirmRemovalWithCascade`, then call `RunRemove(dir, fc, fmtr, ids, a.Stdout)`.\n   - Force path: call `RunRemove(dir, fc, fmtr, ids, a.Stdout)` directly.\n6. Update all tests that call `RunRemove` directly to pass pre-parsed ID slices instead of raw arg slices. If any tests pass `--force` in args to `RunRemove`, adjust them to pass only IDs since force handling is now in `handleRemove`.\n7. Verify `go test ./internal/cli -count=1` and `go test ./internal/storage -count=1` pass.\n\n**Acceptance Criteria**:\n- `Store.ReadTasks` method exists and uses shared (not exclusive) locking\n- `executeRemoval` function with `computeOnly bool` parameter no longer exists\n- `computeBlastRadius` and `applyRemoval` are separate functions with distinct return types\n- `RunRemove` signature matches the `Run*(dir, fc, fmtr, args/ids, stdout)` pattern with no raw-arg parsing\n- `parseRemoveArgs` and the empty-ID validation run exactly once per invocation (in `handleRemove`)\n- The error message `\"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\"` appears exactly once in the codebase\n- Non-force path does not call `Store.Mutate` for blast radius computation\n- All existing tests pass\n- Force and non-force paths produce identical removal results for the same inputs\n\n**Tests**:\n- Run `go test ./internal/storage -run TestReadTasks -count=1` (new test for ReadTasks method) -- returns correct task slice without modifying JSONL file\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions in other commands\n- Run `go test ./... -count=1` -- full suite passes\n- Verify JSONL file is not rewritten during non-force blast radius computation by checking file modification time or content hash in a test","parent":"tick-9c6995","created":"2026-02-19T15:26:31Z","updated":"2026-02-19T15:35:27Z","closed":"2026-02-19T15:35:27Z"}
