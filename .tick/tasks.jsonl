{"id":"tick-132530","title":"Task Removal","status":"done","priority":2,"created":"2026-02-19T11:10:08Z","updated":"2026-02-19T15:18:33Z","closed":"2026-02-19T15:18:33Z"}
{"id":"tick-cf0a05","title":"Phase 1: Walking Skeleton — Single Task Removal","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T11:10:11Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-7314b0","title":"Add FormatRemoval to Formatter interface and all implementations","status":"done","priority":1,"description":"Problem: The Formatter interface has no method for rendering task removal output. Removal is a distinct operation -- not a status transition, dependency change, or generic message. Without a dedicated FormatRemoval method, the RunRemove handler has no way to render structured removal output through the formatter pipeline.\n\nSolution: Add FormatRemoval(result RemovalResult) string to the Formatter interface. Define RemovalResult and RemovedTask structs. Implement on all four formatter types: ToonFormatter, PrettyFormatter (both via baseFormatter embedding), JSONFormatter (structured JSON), and StubFormatter (empty string).\n\nOutcome: The Formatter interface includes FormatRemoval. All four implementations compile and pass tests. Output renders removed task IDs/titles and optional dependency update info.\n\nDo:\n1. Define RemovedTask struct (ID, Title) and RemovalResult struct (Removed []RemovedTask, DepsUpdated []string) in internal/cli/format.go\n2. Add FormatRemoval(result RemovalResult) string to the Formatter interface\n3. Add FormatRemoval to StubFormatter returning empty string\n4. Implement FormatRemoval on baseFormatter: one line per removed task as \"Removed {id} \\\"{title}\\\"\", plus \"Updated dependencies on {id1}, {id2}\" line if DepsUpdated non-empty, joined by newline\n5. ToonFormatter and PrettyFormatter inherit from baseFormatter (no extra code)\n6. Implement FormatRemoval on JSONFormatter: jsonRemovalResult with removed []jsonRemovedTask and deps_updated []string, both always [] not null, via marshalIndentJSON\n7. Add tests in existing test files for each formatter\n\nAcceptance Criteria:\n- Formatter interface includes FormatRemoval(result RemovalResult) string\n- All four formatters satisfy the updated interface (compile-time checks)\n- Toon/Pretty: single removal outputs \"Removed tick-a1b2 \\\"My task\\\"\"\n- JSON: valid JSON with removed array and deps_updated array\n- JSON arrays are [] not null when empty\n- Multiple removed tasks produce one line each (text) or array entries (JSON)\n- DepsUpdated non-empty produces dependency update line/field\n- All existing tests pass\n\nTests:\n- it formats single task removal\n- it formats multiple task removal\n- it formats removal with dependency updates\n- it formats removal with empty deps_updated as empty slice in JSON\n- it formats removal with empty removed as empty slice in JSON\n- it satisfies Formatter interface (compile-time, no regression)\n- StubFormatter.FormatRemoval returns empty string\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:10:18Z","updated":"2026-02-19T13:39:23Z","closed":"2026-02-19T13:39:23Z"}
{"id":"tick-64566b","title":"Implement RunRemove handler with --force flag and wire into App.Run","status":"done","priority":1,"description":"## Problem\n\nTick has no way to permanently delete tasks. The cancel command marks a task as resolved-but-present; there is no mechanism to filter a task out of the JSONL file entirely. The remove command needs a handler that accepts a single task ID, locates the task, filters it from the task slice inside Store.Mutate(), and cleans up dependency references on surviving tasks. The --force flag is required to skip confirmation since this is Phase 1 (confirmation prompts are deferred to a later phase).\n\n## Solution\n\nCreate a RunRemove function in internal/cli/remove.go following the established handler pattern (RunTransition, RunDepAdd). The handler parses --force/-f from subArgs, normalizes the task ID (case-insensitive via task.NormalizeID), opens the store, and calls Store.Mutate(). Inside Mutate, it finds the target task, filters it out of the slice, and strips the removed ID from all surviving tasks' BlockedBy arrays. The result is formatted via the FormatRemoval method (added by task-removal-1-1) and output to stdout. Wire the handler into App.Run via a new handleRemove method dispatched from the switch in app.go.\n\nNote: This task implements single-task removal with --force only. Interactive confirmation (without --force), cascade deletion, bulk removal, and no-args error handling are covered by subsequent tasks.\n\n## Outcome\n\nRunning tick remove tick-abc123 --force removes the task from JSONL, cleans up dependency references on surviving tasks, and outputs the removal result through all three formatters. The command is accessible via tick remove in the CLI dispatch. Case-insensitive ID matching works (e.g., TICK-ABC123 matches tick-abc123).\n\n## Do\n\n1. Create internal/cli/remove.go:\n   - Define parseRemoveArgs(args []string) (id string, force bool, err error) that iterates args, extracts --force/-f as a boolean flag, collects the first positional argument as the task ID (normalized via task.NormalizeID), and returns an error if --force is not set. Error message: \"remove requires --force flag (interactive confirmation not yet implemented)\".\n   - Define RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdout io.Writer) error:\n     - Call parseRemoveArgs(args) to get the ID and force flag.\n     - If no ID provided, return error: \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...] --force\".\n     - Call openStore(dir, fc) and defer store.Close().\n     - Build a RemovalResult to capture output data.\n     - Call store.Mutate: find target task by comparing task.NormalizeID on both sides. If not found, return error \"task '%s' not found\". Record task ID and Title in RemovalResult.Removed. Filter out the task. Iterate remaining tasks and strip removed ID from BlockedBy arrays, recording affected task IDs in RemovalResult.DepsUpdated. Return filtered slice.\n     - If \\!fc.Quiet, output fmtr.FormatRemoval(result) via fmt.Fprintln(stdout, ...).\n\n2. Add handleRemove method to App in internal/cli/app.go:\n   - Follow the pattern of handleTransition: resolve working directory, call RunRemove.\n   - Add case \"remove\": to the switch statement in App.Run.\n\n3. Create internal/cli/remove_test.go with tests listed below.\n\n## Acceptance Criteria\n\n- [ ] tick remove tick-abc123 --force removes the task from JSONL\n- [ ] tick remove TICK-ABC123 --force finds and removes tick-abc123 (case-insensitive)\n- [ ] Surviving tasks with removed task in BlockedBy have that reference stripped\n- [ ] RemovalResult.DepsUpdated lists IDs of tasks whose deps were cleaned up\n- [ ] Output goes through fmtr.FormatRemoval(result) and respects --quiet\n- [ ] tick remove without --force returns an error requiring --force\n- [ ] tick remove --force without an ID returns usage error\n- [ ] tick remove tick-nonexist --force returns \"task 'tick-nonexist' not found\"\n- [ ] The remove subcommand is dispatched correctly from App.Run\n\n## Tests\n\n- \"it removes a single task from JSONL when --force is provided\"\n- \"it matches task ID case-insensitively\"\n- \"it cleans up BlockedBy references on surviving tasks\"\n- \"it reports dependency-updated tasks in RemovalResult\"\n- \"it outputs removal through formatter when not quiet\"\n- \"it suppresses output with --quiet flag\"\n- \"it errors when --force is not provided\"\n- \"it errors when no task ID is provided\"\n- \"it errors when task ID is not found\"\n- \"it dispatches remove command through App.Run\"\n- \"it does not modify other tasks when removing one\"\n\n## Edge Cases\n\n- Case-insensitive ID matching: User may type TICK-ABC123 or Tick-Abc123. Handler normalizes via task.NormalizeID() before searching, consistent with RunTransition. Comparison inside Mutate uses task.NormalizeID() on both sides.\n- Multiple tasks with BlockedBy referencing removed task: When multiple surviving tasks reference the removed task, all must be cleaned up in a single Mutate call.\n\n## Context\n\nFrom the specification: True deletion. The task is filtered from the in-memory slice inside Store.Mutate(), and the JSONL file is rewritten without it. The SQLite cache is rebuilt from JSONL after each write, so the task disappears from both stores atomically.\n\nDependency cleanup: Inside the Mutate callback, after filtering out the removed task(s), iterate remaining tasks and strip all removed IDs from their BlockedBy arrays.\n\nThe --force flag skips interactive confirmation. The RemovalResult struct and FormatRemoval method on the Formatter interface are added by task-removal-1-1 (prerequisite). RemovalResult contains Removed []RemovedTask and DepsUpdated []string. RemovedTask has ID and Title fields.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:15:57Z","updated":"2026-02-19T13:49:10Z","closed":"2026-02-19T13:49:10Z"}
{"id":"tick-0607a0","title":"Handle remove error cases","status":"done","priority":1,"description":"## Problem\n\nTask 1-2 defines error handling in RunRemove but the no-args error message includes a --force suffix that deviates from the spec-mandated message. The spec explicitly states this message should be consistent with existing commands like start, done, cancel, which do not include flags in their usage hint. This task ensures all error messages match the specification exactly and are verified through dedicated tests at the App.Run integration level.\n\n## Solution\n\nCorrect the no-args error message in parseRemoveArgs (or RunRemove) to match the spec exactly, and add focused tests that assert the precise error message text for all error paths: no arguments, task not found, and missing --force. Tests verify both the exact error string and the App.Run-level behavior (stderr output, exit code 1).\n\n## Outcome\n\nAll remove error messages match the specification word-for-word. Dedicated tests assert exact error text (not just substring containment) for the no-args case, ensuring future changes cannot silently drift from the spec.\n\n## Do\n\n1. In internal/cli/remove.go, change the no-ID error message from \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...] --force\" to \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" to match the spec exactly.\n2. Add tests in internal/cli/remove_test.go that verify error cases through App.Run integration:\n   - No arguments: assert stderr contains exactly \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" and exit code is 1.\n   - Task not found: assert stderr contains \"task 'tick-nonexist' not found\" and exit code is 1.\n   - Missing --force: assert stderr contains \"remove requires --force flag\" and exit code is 1.\n3. Verify that the \"Error: \" prefix is applied by App.Run -- tests at the App level should check for \"Error: task ID is required...\" in stderr.\n\n## Acceptance Criteria\n\n- [ ] No-args error message is exactly \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" (no --force suffix)\n- [ ] Not-found error message is \"task '\u003cid\u003e' not found\" using the normalized ID\n- [ ] Missing --force error message communicates that --force is required\n- [ ] All three error cases produce exit code 1 when run through App.Run\n- [ ] All three error cases write the error to stderr (prefixed with \"Error: \" by App.Run)\n- [ ] All existing tests continue to pass\n\n## Tests\n\n- \"it returns exact spec-mandated message when no arguments provided\"\n- \"it returns not-found error for nonexistent task ID\"\n- \"it returns error when --force flag is missing\"\n- \"it returns exact spec-mandated message when only --force provided without ID\"\n\n## Edge Cases\n\n- No-args message must match the spec exactly: \"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\" -- consistent with start, done, cancel which omit flags from their usage hints.\n- tick remove --force (flag but no positional ID): --force is consumed as a flag, no positional arg remains, so the no-ID error triggers.\n\n## Context\n\nFrom the specification: \"If no task IDs are provided, the command returns an error: 'task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]'. Consistent with existing commands like start, done, cancel.\"\n\nExisting pattern from internal/cli/transition.go: return fmt.Errorf(\"task ID is required. Usage: tick %s \u003cid\u003e\", command) -- no flags in the usage hint.\n\nFrom internal/cli/app.go: all handler errors are printed as \"Error: %s\" to stderr and return exit code 1.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:24:25Z","updated":"2026-02-19T13:53:22Z","closed":"2026-02-19T13:53:22Z"}
{"id":"tick-1777bc","title":"Register remove command help text","status":"done","priority":1,"description":"**Problem**: The remove command needs a help entry in the commands registry in internal/cli/help.go so that tick help, tick help remove, tick help --all, and tick remove --help all display correct usage, description, and flags.\n\n**Solution**: Add a commandInfo entry for remove to the commands slice in help.go. The entry includes the command name, one-line summary, usage string, multi-line description (covering cascade behavior and Git recovery), and the --force / -f flag. The existing help infrastructure renders it automatically.\n\n**Outcome**: tick help lists remove alongside all other commands. tick help remove prints detailed usage including the --force flag, cascade deletion note, and Git recovery guidance. tick help --all includes the remove entry.\n\n**Do**:\n1. In internal/cli/help.go, add a new commandInfo entry to the commands slice after reopen, before dep:\n   - Name: \"remove\"\n   - Summary: \"Permanently remove tasks from the project\"\n   - Usage: \"tick remove \u003cid\u003e [\u003cid\u003e...] [flags]\"\n   - Description: covers permanent deletion from JSONL, cascade to descendants, dep cleanup on survivors, Git recovery\n   - Flags: --force / -f with description \"Skip confirmation prompt\"\n2. In internal/cli/help_test.go, update \"tick help shows all commands\" test to include \"remove\"\n3. Add subtests: \"tick help remove shows flags\", \"tick help remove mentions cascade\", \"tick help remove mentions git recovery\"\n\n**Acceptance Criteria**:\n- [ ] commands slice contains commandInfo with Name: \"remove\"\n- [ ] Remove entry has Usage showing \u003cid\u003e [\u003cid\u003e...]\n- [ ] Remove entry has Flags with --force / -f\n- [ ] Remove entry Description mentions cascade deletion\n- [ ] Remove entry Description mentions Git history as recovery\n- [ ] tick help output includes remove\n- [ ] tick help remove output includes --force flag\n- [ ] tick help --all includes remove\n- [ ] All existing help tests pass\n\n**Tests**:\n- \"tick help shows all commands\" — updated to expect remove\n- \"tick help remove shows flags\" — verifies --force appears\n- \"tick help remove mentions cascade\" — verifies cascade/descendants mentioned\n- \"tick help remove mentions git recovery\" — verifies Git recovery referenced\n\n**Context**:\nFrom the specification: \"The remove command's help entry should document: Usage and flags, Cascade behavior (removing a parent removes all descendants), That Git history serves as the recovery mechanism for accidental removals.\"\n\nThe commands slice in help.go is the single registry — adding an entry makes the command visible everywhere automatically.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-cf0a05","created":"2026-02-19T11:28:14Z","updated":"2026-02-19T13:56:51Z","closed":"2026-02-19T13:56:51Z"}
{"id":"tick-fca658","title":"Phase 2: Interactive Confirmation Prompt","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T11:50:21Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-8bc489","title":"Add Stdin to App and thread through remove handler","status":"done","priority":2,"description":"Problem: The App struct has no Stdin field. The upcoming confirmation prompt needs to read user input from stdin, but RunRemove currently accepts only (dir, fc, fmtr, args, stdout) -- there is no io.Reader parameter for stdin. Without injectable stdin, the confirmation prompt cannot be tested in isolation.\n\nSolution: Add a Stdin io.Reader field to the App struct in internal/cli/app.go. Inject os.Stdin in cmd/tick/main.go. Extend RunRemove's signature to accept an io.Reader parameter for stdin. Update handleRemove to pass a.Stdin through. Remove the hard error on missing --force (replacing it with a placeholder that the next task will fill in). Update all existing test helpers that construct App{} to include the new Stdin field.\n\nOutcome: App has an injectable Stdin io.Reader field. RunRemove receives stdin as a parameter. Production code passes os.Stdin. Tests pass a bytes.Buffer or strings.NewReader. The --force path continues to work unchanged. Without --force, RunRemove no longer errors with \"not yet implemented\" -- instead it accepts the io.Reader argument (the actual prompt logic is deferred to task-removal-2-2).\n\nDo:\n1. In internal/cli/app.go, add Stdin io.Reader field to the App struct with comment: \"Stdin is the standard input reader. Injected for testability (confirmation prompts).\"\n2. In cmd/tick/main.go, set Stdin: os.Stdin in the App struct literal.\n3. In internal/cli/remove.go, change RunRemove signature to include stdin io.Reader parameter (placed before stdout io.Writer).\n4. In RunRemove, remove the hard error for missing --force. When force is false, proceed without error. Add a TODO comment for task-removal-2-2 to add the confirmation prompt.\n5. In internal/cli/app.go, update handleRemove to pass a.Stdin to RunRemove.\n6. Update all test call sites in remove_test.go that call RunRemove directly to pass a stdin argument (e.g., strings.NewReader(\"\")). Update App{} struct literals in remove tests to include Stdin.\n7. Replace the test asserting \"remove requires --force flag\" error with a test verifying RunRemove succeeds without --force.\n8. Existing non-remove test files need no changes -- nil Stdin is safe for all other commands.\n\nAcceptance Criteria:\n- [ ] App struct in internal/cli/app.go has Stdin io.Reader field\n- [ ] cmd/tick/main.go sets Stdin: os.Stdin on the App struct\n- [ ] RunRemove signature includes stdin io.Reader parameter\n- [ ] handleRemove passes a.Stdin to RunRemove\n- [ ] RunRemove does not error when --force is omitted\n- [ ] tick remove \u003cid\u003e --force continues to work exactly as before\n- [ ] All existing tests pass (no regressions)\n- [ ] Remove tests construct App{} with Stdin populated\n\nTests:\n- \"it includes Stdin field on App struct and threads to RunRemove\"\n- \"it does not error when --force is omitted\"\n- \"it preserves --force removal behavior from Phase 1\"\n- \"it passes nil stdin safely for non-remove commands\"\n\nContext: From the spec, the user must enter explicit confirmation to proceed (case-insensitive y or yes). This requires reading from stdin, motivating the Stdin field. The confirmation prompt is written to stderr (Stderr already exists on App). The existing DI pattern (Stdout, Stderr, Getwd, IsTTY) establishes the convention. RunRemove is the first command requiring user input, hence the unique stdin parameter.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-64566b"],"parent":"tick-fca658","created":"2026-02-19T11:50:30Z","updated":"2026-02-19T14:01:25Z","closed":"2026-02-19T14:01:25Z"}
{"id":"tick-0c56d2","title":"Implement confirmation prompt with accept and abort paths","status":"done","priority":2,"description":"Problem: When --force is not provided, RunRemove currently proceeds without any confirmation gate (after task-removal-2-1 replaced the hard error with a placeholder). The specification requires an interactive confirmation prompt before removal -- the user must explicitly type y or yes to proceed. Without this gate, accidental removal of tasks has no safety net. The prompt text and abort message must go to stderr (keeping stdout clean for piped usage), and abort must exit with code 1.\n\nSolution: Add a stderr io.Writer parameter to RunRemove and thread a.Stderr from handleRemove. When --force is false, write a confirmation prompt to stderr showing the task ID and title with [y/N] convention, read one line from stdin via bufio.NewReader, trim whitespace, compare case-insensitively against y/yes. On acceptance, proceed with removal. On any other input (including empty Enter), write \"Aborted.\" to stderr and return a sentinel error that App.Run translates to exit code 1 without the standard \"Error: \" prefix.\n\nOutcome: Running tick remove \u003cid\u003e without --force displays a confirmation prompt on stderr, reads input from stdin, and either proceeds with removal (on y/yes) or aborts with \"Aborted.\" on stderr and exit code 1. The --force flag continues to skip the prompt entirely.\n\nDo:\n1. In internal/cli/remove.go, add a stderr io.Writer parameter to RunRemove after stdin io.Reader. New signature: RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdin io.Reader, stderr io.Writer, stdout io.Writer) error.\n2. Define a sentinel error in internal/cli/remove.go: var errAborted = errors.New(\"aborted\"). This distinguishes user-declined aborts from real errors.\n3. In RunRemove, replace the TODO placeholder for the non-force path with confirmation logic:\n   - Look up the target task to get its title before prompting.\n   - Write the prompt to stderr: fmt.Fprintf(stderr, \"Remove task %s \\\"%s\\\"? [y/N] \", id, title).\n   - Read one line from stdin using bufio.NewReader(stdin).ReadString('\\n').\n   - Trim with strings.TrimSpace and lowercase with strings.ToLower.\n   - If normalized response is \"y\" or \"yes\", proceed with removal.\n   - Otherwise, write fmt.Fprintln(stderr, \"Aborted.\") and return errAborted.\n4. In internal/cli/app.go, update handleRemove to pass a.Stderr to RunRemove.\n5. In internal/cli/app.go, update the error handling block after the command switch to detect errAborted: if errors.Is(err, errAborted) { return 1 } before the \"Error: \" prefix logic.\n6. Update all test call sites in remove_test.go that call RunRemove directly to include the new stderr parameter (pass a \u0026bytes.Buffer{}).\n7. Add tests for confirmation prompt behavior.\n\nAcceptance Criteria:\n- [ ] Without --force, RunRemove writes prompt \"Remove task \u003cid\u003e \\\"\u003ctitle\u003e\\\"? [y/N] \" to stderr\n- [ ] Entering y (lowercase) proceeds with removal and outputs result to stdout\n- [ ] Entering Y (uppercase) proceeds with removal\n- [ ] Entering yes/YES/yEs (case-insensitive) proceeds with removal\n- [ ] Empty Enter writes \"Aborted.\" to stderr and returns exit code 1\n- [ ] Entering n, no, maybe, or any non-y/yes input writes \"Aborted.\" to stderr and returns exit code 1\n- [ ] Whitespace-padded input (\"  y  \") proceeds with removal after trimming\n- [ ] Prompt text and \"Aborted.\" message are written to stderr, not stdout\n- [ ] Stdout remains empty on abort\n- [ ] --force continues to skip the prompt entirely\n- [ ] App.Run returns exit code 1 on abort without printing \"Error: \" prefix\n- [ ] All existing tests continue to pass\n\nTests:\n- \"it prompts for confirmation on stderr when --force is not provided\"\n- \"it proceeds with removal when user enters y\"\n- \"it proceeds with removal when user enters Y (uppercase)\"\n- \"it proceeds with removal when user enters yes\"\n- \"it proceeds with removal when user enters YES (case-insensitive)\"\n- \"it aborts when user presses Enter (empty input)\"\n- \"it aborts when user enters n\"\n- \"it aborts when user enters arbitrary text\"\n- \"it trims whitespace from user input before comparing\"\n- \"it writes Aborted message to stderr on decline\"\n- \"it does not write to stdout on abort\"\n- \"it skips prompt entirely when --force is provided\"\n- \"it returns exit code 1 on abort without Error prefix via App.Run\"\n\nEdge Cases:\n- Case-insensitive y/yes: strings.ToLower(strings.TrimSpace(input)) handles all combinations\n- Empty Enter aborts: ReadString returns newline, TrimSpace becomes empty string\n- Whitespace-padded input: trimmed before comparison\n- EOF on stdin: treat as abort\n- errAborted sentinel: must not leak through App.Run's Error prefix\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-fca658","created":"2026-02-19T11:54:14Z","updated":"2026-02-19T14:12:55Z","closed":"2026-02-19T14:12:55Z"}
{"id":"tick-192a68","title":"Phase 3: Cascade Deletion, Dependency Cleanup, and Bulk Removal","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T12:01:56Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-2a1fa5","title":"Bulk argument parsing with deduplication","status":"done","priority":2,"description":"Problem: parseRemoveArgs currently returns a single task ID (id string). The specification requires tick remove \u003cid\u003e [\u003cid\u003e...] supporting multiple positional arguments. Before cascade, validation, or the confirmation prompt can work with multiple targets, the argument parsing layer must collect all positional IDs, deduplicate them, and return them as a slice.\n\nSolution: Refactor parseRemoveArgs in internal/cli/remove.go to return a slice of deduplicated, normalized task IDs instead of a single ID. The function iterates args, skips --force/-f flags (and any unknown flags starting with -), collects all other positional arguments as task IDs, normalizes each via task.NormalizeID, deduplicates using a seen-set, and preserves the first-occurrence order. Update RunRemove and all existing call sites/tests to use the new return type.\n\nOutcome: parseRemoveArgs returns (ids []string, force bool, err error) where ids is a deduplicated, normalized slice of task IDs. All existing single-ID tests pass without behavioral change.\n\nDo:\n1. In internal/cli/remove.go, change parseRemoveArgs signature from (args []string) (id string, force bool, err error) to (args []string) (ids []string, force bool, err error).\n2. Replace single-ID extraction with loop: iterate args, --force/-f sets force, - prefix skips, otherwise normalize via task.NormalizeID and append to candidates. Deduplicate with map[string]bool preserving first-occurrence order.\n3. Update RunRemove: change no-ID check from if id == \"\" to if len(ids) == 0. For Mutate callback and confirmation prompt, continue using ids[0] as single target (tasks 3-2 through 3-5 extend to full slice).\n4. Update all existing tests to destructure new return type (ids, force, err) and assert ids[0].\n5. Add new TestParseRemoveArgs subtests for bulk and deduplication scenarios.\n\nAcceptance Criteria:\n- [ ] parseRemoveArgs returns ([]string, bool, error) instead of (string, bool, error)\n- [ ] Single ID input returns slice of length 1 with normalized ID\n- [ ] Multiple IDs return all IDs in order, normalized\n- [ ] Duplicate IDs silently deduplicated, preserving first-occurrence order\n- [ ] Case-variant duplicates (TICK-AAA and tick-aaa) treated as same ID and deduplicated\n- [ ] --force and -f extracted regardless of position among IDs\n- [ ] Unknown flags skipped without error\n- [ ] No positional arguments returns empty slice\n- [ ] All existing single-ID removal tests pass\n- [ ] RunRemove works with refactored return type\n\nTests:\n- parseRemoveArgs returns single ID as slice of length 1\n- parseRemoveArgs returns multiple IDs in order\n- parseRemoveArgs normalizes IDs to lowercase\n- parseRemoveArgs deduplicates identical IDs\n- parseRemoveArgs deduplicates case-variant IDs\n- parseRemoveArgs preserves first-occurrence order after dedup\n- parseRemoveArgs extracts --force from between IDs\n- parseRemoveArgs extracts -f shorthand flag\n- parseRemoveArgs handles --force before and after all IDs\n- parseRemoveArgs skips unknown flags mixed with IDs\n- parseRemoveArgs returns empty slice when only flags or no args provided\n- RunRemove still removes single task with refactored parseRemoveArgs\n\nEdge Cases:\n- Duplicate IDs silently deduplicated: tick remove tick-aaa tick-aaa --force produces ids=[\"tick-aaa\"]\n- Case-variant duplicates: tick remove TICK-AAA tick-aaa deduplicates to [\"tick-aaa\"]\n- Single ID still works: ids[0] used where id was previously\n- Mixed flags and positional args: --unknown silently skipped\n- --force only (no IDs): returns ids=[] and force=true, RunRemove returns usage error\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-64566b"],"parent":"tick-192a68","created":"2026-02-19T12:02:08Z","updated":"2026-02-19T14:17:15Z","closed":"2026-02-19T14:17:15Z"}
{"id":"tick-37bab0","title":"All-or-nothing ID validation for bulk removal","status":"done","priority":2,"description":"## Problem\n\nRunRemove currently validates a single task ID inside the Store.Mutate callback by searching for it in the task slice and returning \"task '%s' not found\" if absent. After task-removal-3-1, parseRemoveArgs returns a []string of deduplicated IDs, but RunRemove still uses only ids[0]. When bulk removal is introduced, if validation happens per-task during filtering, the first valid task could be removed before the second invalid task triggers an error -- violating the all-or-nothing guarantee.\n\n## Solution\n\nAdd a validation step at the top of the Store.Mutate callback that builds a lookup set from the task slice and checks every ID. If any is missing, return an error immediately before any filtering. Replace single-task filtering with removeSet map for O(1) lookup. Extend dep cleanup to strip all removed IDs.\n\n## Outcome\n\nWhen any ID in a bulk tick remove invocation does not exist, the command fails with \"task '\u003cid\u003e' not found\" and zero tasks are removed. When all IDs exist, removal proceeds atomically.\n\n## Do\n\n1. In internal/cli/remove.go, inside RunRemove's store.Mutate callback, add validation: build existingIDs map from task slice, iterate ids, error on first missing ID.\n2. Update RunRemove to use full ids slice. Build removeSet map for O(1) filtering. Collect RemovalResult.Removed entries for all validated IDs.\n3. Update dep cleanup loop to strip all IDs in removeSet from surviving tasks' BlockedBy arrays.\n4. For confirmation prompt (non-force): look up each ID's title and prompt with the full set.\n5. Add tests for validation edge cases.\n\n## Acceptance Criteria\n\n- [ ] When all provided IDs exist, all corresponding tasks are removed in a single Mutate call\n- [ ] When first ID valid but second invalid, zero tasks removed, error reports invalid ID\n- [ ] When all IDs invalid, zero tasks removed, error reports first invalid ID\n- [ ] Error message format is \"task '\u003cid\u003e' not found\" using normalized ID\n- [ ] Dependency cleanup handles all removed IDs, not just one\n- [ ] Single-ID removal continues to work identically\n- [ ] JSONL file unchanged when validation fails\n- [ ] All existing remove tests pass\n\n## Tests\n\n- \"it removes multiple tasks when all IDs are valid\"\n- \"it fails with not-found error when first ID is valid but second is invalid\"\n- \"it fails with not-found error when all IDs are invalid\"\n- \"it removes zero tasks when any ID is invalid (all-or-nothing)\"\n- \"it reports the first invalid ID in the error message\"\n- \"it cleans up BlockedBy references for all removed task IDs\"\n- \"it preserves single-ID removal behavior\"\n- \"it does not modify JSONL when validation fails\"\n\n## Edge Cases\n\n- First ID valid, second invalid: first missing ID triggers error, no tasks removed\n- All IDs invalid: first ID in ids slice triggers error immediately\n- Duplicate IDs after dedup: already handled by task-removal-3-1\n- Single ID not found: existing behavior preserved\n\n## Context\n\nFrom the spec: \"If any provided task ID does not exist, the command fails with an error before any removal occurs. No partial removal -- either all targets are valid and removed, or none are.\"\n\nValidation occurs inside Store.Mutate which holds exclusive file lock. Returning error causes Store.Mutate to skip JSONL write entirely, guaranteeing atomicity. The ids slice is already deduplicated and normalized by parseRemoveArgs (task-removal-3-1).\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:05:39Z","updated":"2026-02-19T14:23:46Z","closed":"2026-02-19T14:23:46Z"}
{"id":"tick-5b74ec","title":"Cascade descendant collection","status":"done","priority":2,"description":"Problem: When a parent task is removed, all its descendants (children, grandchildren, etc.) must also be removed. The removal flow operates inside Store.Mutate() on an in-memory []task.Task slice, where SQLite is not available. There is no in-memory function to recursively collect all descendants of a given set of task IDs from a task slice.\n\nSolution: Implement a standalone collectDescendants function in internal/cli/remove.go that takes a set of target IDs and the full []task.Task slice, then returns the complete set of IDs to remove (targets + all recursive descendants). Builds a parent-to-children index, walks recursively for each target. Pure function, independently testable.\n\nOutcome: A tested collectDescendants function exists that, given target IDs and a task slice, returns the deduplicated union of those targets plus all their transitive descendants. Task 3-4 will call this function inside the Mutate callback.\n\nDo:\n1. In internal/cli/remove.go, add collectDescendants(targetIDs map[string]bool, tasks []task.Task) map[string]bool:\n   - Build childrenOf map (map[string][]string) by iterating tasks, grouping by task.NormalizeID(t.Parent) where Parent is non-empty\n   - Start with result set initialized from targetIDs\n   - For each target ID, recursively walk childrenOf to collect all descendant IDs\n   - Return combined set (targets + descendants)\n2. In internal/cli/remove_test.go, add TestCollectDescendants with subtests.\n\nAcceptance Criteria:\n- [ ] collectDescendants returns only target IDs when none have children\n- [ ] collectDescendants returns target + direct children when target has children\n- [ ] collectDescendants returns target + all transitive descendants for 3+ level hierarchies\n- [ ] Removing a child does not cascade upward -- parent and siblings not included\n- [ ] Descendants already in target set are not duplicated\n- [ ] Multiple targets with overlapping subtrees: descendant appears once\n- [ ] Empty targetIDs input returns empty result set\n- [ ] Tasks with no Parent field never collected as descendants\n- [ ] ID comparison uses task.NormalizeID for case-insensitive matching\n\nTests:\n- \"target with no children returns only target\"\n- \"target with direct children collects them\"\n- \"deep hierarchy collects all levels\" (A -\u003e B -\u003e C -\u003e D)\n- \"child removal does not cascade upward\" (targeting B in A-\u003eB-\u003eC returns {B,C} not {A,B,C})\n- \"target already includes descendant deduplicates\"\n- \"multiple targets with overlapping descendants\"\n- \"empty target set returns empty result\"\n- \"case-insensitive ID matching\"\n\nEdge Cases:\n- Deep hierarchy (3+ levels): recursive walk must not stop at direct children\n- Task with no children: returns only original targets, no nil-map issues\n- Child removal does not cascade upward: walks Parent-\u003eChildren direction only\n- Mixed-case IDs: task.NormalizeID applied consistently\n\nContext:\nFrom the spec: \"When a task with children is removed, all descendants are collected recursively.\" The existing queryDescendantIDs in list.go uses SQLite recursive CTE but the removal flow needs an in-memory equivalent inside the Mutate callback. Task.Parent field is the only relationship link. Function signature uses map[string]bool consistent with removeSet from task 3-2.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:13:40Z","updated":"2026-02-19T14:28:03Z","closed":"2026-02-19T14:28:03Z"}
{"id":"tick-9e0c27","title":"Integrate cascade into removal flow with confirmation prompt","status":"done","priority":2,"description":"## Problem\n\nAfter tasks 3-2 and 3-3, RunRemove can validate and remove multiple IDs atomically with dependency cleanup, and collectDescendants can compute the full set of transitive descendants. However, collectDescendants is not called anywhere in the removal flow. Parent tasks are removed without their descendants, leaving orphaned children. The confirmation prompt only shows explicitly targeted tasks, not the cascade blast radius.\n\n## Solution\n\nWire collectDescendants into the RunRemove flow. After all-or-nothing ID validation but before filtering, call collectDescendants(removeSet, tasks) to expand the remove set with all transitive descendants. Update the confirmation prompt (non-force path) to show the full blast radius: explicitly targeted tasks plus cascaded descendants. Ensure dependency cleanup iterates the expanded remove set. With --force, cascade proceeds silently.\n\n## Outcome\n\nRunning tick remove \u003cparent-id\u003e removes the parent and all descendants atomically. The confirmation prompt (without --force) lists all tasks that will be removed, distinguishing targets from descendants. Dependency cleanup scrubs all removed IDs from surviving tasks' BlockedBy arrays. --force skips the prompt but still cascades.\n\n## Do\n\n1. In internal/cli/remove.go, inside RunRemove, after the all-or-nothing ID validation loop and before the confirmation prompt / filtering logic, call collectDescendants(removeSet, tasks) and reassign the result to removeSet.\n\n2. Update the pre-prompt task lookup to collect information for all IDs in the expanded removeSet. Build three collections:\n   - targetTasks: tasks explicitly passed as arguments (original ids slice)\n   - cascadedTasks: tasks added by collectDescendants (in removeSet but not in original ids set)\n   - affectedDepTasks: surviving tasks (not in removeSet) that have any removeSet ID in their BlockedBy arrays — these will have dependency references cleaned up\n\n3. Update the confirmation prompt logic (non-force path) to display the full blast radius on stderr:\n   - Single target, no cascade, no dep impact: keep existing format -- Remove task tick-abc \"Title\"? [y/N]\n   - When cascade applies: show target, list cascaded descendants\n   - When surviving tasks have dependency references: list which surviving tasks will have dependency references cleaned (e.g., \"Will update dependencies on tick-def, tick-ghi\")\n   - Multiple targets: list all targets, then additional cascaded descendants, then affected dependencies\n   Prompt must surface every task that will be removed, distinguish descendants from explicit targets, and show which surviving tasks will have dependency references cleaned.\n\n4. Ensure filtering step uses expanded removeSet for keeping/removing tasks, recording RemovalResult.Removed, and stripping from surviving tasks' BlockedBy arrays.\n\n5. In internal/cli/remove_test.go, add tests for cascade integration.\n\n## Acceptance Criteria\n\n- [ ] Removing a parent task also removes all transitive descendants in a single Store.Mutate call\n- [ ] Removing a leaf (child) task does not remove its parent or siblings\n- [ ] Confirmation prompt (without --force) lists all tasks including cascaded descendants\n- [ ] Prompt distinguishes explicitly targeted tasks from cascaded descendants\n- [ ] Confirmation prompt (without --force) lists surviving tasks whose dependency references will be cleaned\n- [ ] --force with cascade proceeds silently without any prompt\n- [ ] RemovalResult.Removed includes targets and all cascaded descendants\n- [ ] Dependency cleanup scrubs all removed IDs (targets + descendants) from surviving tasks' BlockedBy\n- [ ] RemovalResult.DepsUpdated reflects tasks whose BlockedBy was cleaned of any expanded-set ID\n- [ ] Prompt text and abort message written to stderr\n- [ ] Single target with no children and no dep impact retains existing simple prompt format\n- [ ] All existing remove tests continue to pass\n\n## Tests\n\n- \"it removes parent and all descendants when removing a parent with --force\"\n- \"it removes 3-level hierarchy (parent -\u003e child -\u003e grandchild) with --force\"\n- \"it does not remove parent when removing a child with --force\"\n- \"it does not remove siblings when removing a child with --force\"\n- \"it shows descendants in confirmation prompt when removing parent without --force\"\n- \"it shows affected dependency tasks in confirmation prompt\"\n- \"it proceeds with cascade removal when user confirms with y\"\n- \"it aborts cascade removal when user declines\"\n- \"it skips prompt entirely with --force for cascade removal\"\n- \"it cleans BlockedBy references for all cascaded descendant IDs on surviving tasks\"\n- \"it reports all cascade-removed tasks in RemovalResult.Removed\"\n- \"it reports dep-updated tasks in RemovalResult.DepsUpdated for cascade-removed IDs\"\n- \"it retains simple prompt format for single target with no children and no dep impact\"\n- \"it writes cascade prompt to stderr not stdout\"\n\n## Edge Cases\n\n- Cascade with --force skips prompt: collectDescendants expands set, filtering proceeds, no stdin/stderr interaction\n- Prompt lists all cascaded descendants: user must see every task before confirming\n- Dependency cleanup covers all removed IDs: surviving task blocked by both parent and grandchild must have both stripped\n- Single target with no children and no dep impact: prompt remains Phase 2 format, no noise\n- Removing a child does not cascade upward: only child and its own descendants removed\n\n## Context\n\nFrom the spec: \"When a task with children is removed, all descendants are collected recursively. All collected tasks are removed in a single atomic Store.Mutate() call. Dependency references for all removed tasks are auto-cleaned from surviving tasks.\"\n\nConfirmation prompt: \"Explicitly lists all tasks that will be removed.\" The prompt surfaces blast radius including dependency references that will be cleaned from surviving tasks. With --force: \"Cascade proceeds silently.\"\n\ncollectDescendants (task 3-3) takes targetIDs map[string]bool and tasks []task.Task, returns map[string]bool. removeSet (task 3-2) is the input; returned map replaces it.\n\nRemovalResult (task 1-1) has Removed []RemovedTask and DepsUpdated []string. Both must reflect the expanded set.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","blocked_by":["tick-0c56d2"],"parent":"tick-192a68","created":"2026-02-19T12:18:05Z","updated":"2026-02-19T14:38:18Z","closed":"2026-02-19T14:38:18Z"}
{"id":"tick-0424d3","title":"Bulk and cascade interaction with cross-target deduplication","status":"done","priority":2,"description":"## Problem\n\nAfter tasks 3-1 through 3-4, RunRemove supports bulk IDs, all-or-nothing validation, cascade descendant collection, and an expanded confirmation prompt. However, no tests verify the interaction between bulk removal and cascade when they combine. Three untested scenarios: (1) task is both explicit arg and cascaded descendant, (2) two targets where one is ancestor of the other, (3) bulk leaf removal with no cascade.\n\n## Solution\n\nAdd focused integration tests in internal/cli/remove_test.go exercising combined bulk + cascade paths through RunRemove. Fix any discovered bugs.\n\n## Outcome\n\nAll interaction scenarios covered by passing tests. Explicit-arg-plus-cascade overlap handled silently, shared descendants deduplicated, bulk leaf removal works without cascade side effects. Any discovered bugs fixed.\n\n## Do\n\n1. In internal/cli/remove_test.go, add TestBulkCascadeInteraction test group.\n\n2. Subtest: \"explicit arg that is also a cascaded descendant is removed once\" -- Create A -\u003e B -\u003e C, plus unrelated D. RunRemove with [A, B, --force]. Assert: A, B, C removed, D survives. RemovalResult.Removed has 3 entries, no duplicates.\n\n3. Subtest: \"two targets where one is ancestor of the other\" -- Create A -\u003e B -\u003e C. RunRemove with [A, C, --force]. All three removed once. RemovalResult.Removed has 3 entries.\n\n4. Subtest: \"bulk removal of unrelated leaf tasks\" -- Create A, B, C, D (all leaves). RunRemove with [A, C, --force]. A and C removed, B and D survive. RemovalResult.Removed has 2 entries.\n\n5. Subtest: \"dependency cleanup covers all expanded cascade IDs\" -- Create Parent -\u003e Child1, Parent -\u003e Child2. Create Survivor with BlockedBy: [Child1, Child2]. RunRemove with [Parent, --force]. All three removed. Survivor's BlockedBy empty. DepsUpdated includes Survivor.\n\n6. Subtest: \"confirmation prompt shows deduplicated blast radius for bulk+cascade\" -- Create A -\u003e B -\u003e C, plus leaf D. RunRemove with [A, B, D] (no --force), stdin \"y\\n\". Assert stderr mentions A, B, C, D. B not listed twice. All four removed.\n\n7. Subtest: \"confirmation prompt abort prevents any removal for bulk+cascade\" -- Create A -\u003e B, C (leaf). RunRemove with [A, C] (no --force), stdin \"n\\n\". All tasks survive. stderr contains \"Aborted.\"\n\n## Acceptance Criteria\n\n- [ ] Task appearing as both explicit argument and cascaded descendant is removed exactly once\n- [ ] When one explicit target is ancestor of another, cascade deduplicates\n- [ ] Bulk removal of unrelated leaf tasks removes exactly those tasks\n- [ ] Dependency cleanup scrubs all expanded cascade IDs from surviving BlockedBy\n- [ ] Confirmation prompt displays full deduplicated set for bulk+cascade\n- [ ] Declining confirmation aborts without removing any tasks\n- [ ] No duplicate entries in RemovalResult.Removed\n- [ ] All existing remove tests pass\n\n## Tests\n\n- \"explicit arg that is also a cascaded descendant is removed once\"\n- \"two targets where one is ancestor of the other\"\n- \"bulk removal of unrelated leaf tasks\"\n- \"dependency cleanup covers all expanded cascade IDs\"\n- \"confirmation prompt shows deduplicated blast radius for bulk+cascade\"\n- \"confirmation prompt abort prevents any removal for bulk+cascade\"\n\n## Edge Cases\n\n- Explicit + cascade overlap: map[string]bool naturally deduplicates. RemovalResult.Removed collection must not double-count.\n- Ancestor/descendant targets: collectDescendants walks from each target, merges into same map.\n- Leaf bulk: collectDescendants returns input unchanged. Verifies no spurious cascade.\n- Dep cleanup for expanded set: surviving task referencing multiple removed IDs must have all scrubbed.\n\n## Context\n\nFrom the spec: \"Deduplication also applies when a task appears both as an explicit argument and as a cascaded descendant -- it is only removed once.\" and \"Bulk + cascade interaction: all targets plus descendants collected, deduplicated, removed atomically.\"\n\nImplementation uses map[string]bool throughout (removeSet, collectDescendants output), so deduplication is inherent. These tests verify end-to-end behavior through RunRemove.\n\nSpec Reference: docs/workflow/specification/task-removal/specification.md","parent":"tick-192a68","created":"2026-02-19T12:22:35Z","updated":"2026-02-19T14:42:52Z","closed":"2026-02-19T14:42:52Z"}
{"id":"tick-d5946b","title":"Phase 4: Analysis (cycle 1)","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T14:59:09Z","updated":"2026-02-19T15:18:24Z","closed":"2026-02-19T15:18:24Z"}
{"id":"tick-cf66a9","title":"Consolidate blast radius computation into Mutate callback","status":"done","priority":2,"description":"severity: high\nsources: duplication, architecture\n\n**Problem**: `computeBlastRadius` (lines 58-141) and the `Mutate` callback in `RunRemove` (lines 172-223) both independently (1) validate all IDs exist with all-or-nothing semantics, (2) build a removeSet from explicit targets, and (3) expand that set with transitive descendants. The blast radius function does this via SQL queries with an iterative fixed-point loop; the Mutate callback does it via the in-memory task slice using `collectDescendants`. This creates ~30 lines of duplicated logic, a maintenance burden (changes must be synced across both paths), a theoretical TOCTOU gap between the Query read and the Mutate write, a duplicate type (`idTitle` in remove.go mirrors `RemovedTask` in format.go), and a non-standard inline interface parameter on `computeBlastRadius`.\n\n**Solution**: Restructure so the Mutate callback is the single source of truth for validation and descendant expansion. Introduce a \"dry run\" mode: the Mutate callback computes the full blast radius (removed tasks, cascaded descendants, affected deps) and returns it without persisting when a flag indicates dry-run. For the non-force path, call Mutate in dry-run mode to get the blast radius for the confirmation prompt, then call Mutate again for the real removal if the user confirms. For the force path, call Mutate once (real mode). This eliminates `computeBlastRadius` entirely along with its SQL queries, the `idTitle` type (use `RemovedTask` for prompt data too), and the inline interface.\n\n**Outcome**: One code path for validation and descendant expansion. No duplicate types. No inline interface. The confirmation prompt shows data computed by the same algorithm that performs the actual removal. The TOCTOU gap is narrowed to an inherent property of the confirmation pattern rather than being amplified by divergent code paths.\n\n**Do**:\n1. In `internal/cli/remove.go`, replace the `idTitle` type with `RemovedTask` from `format.go` in the `blastRadius` struct fields (`targetTasks`, `cascadedTasks`, `affectedDeps`).\n2. Update `confirmRemovalWithCascade` to accept a `blastRadius` that uses `RemovedTask` fields (access `.ID` and `.Title` instead of `.id` and `.title`).\n3. Refactor the Mutate callback into a named function (e.g., `executeRemoval`) that takes the task slice and target IDs, performs validation, descendant expansion via `collectDescendants`, filtering, and dep cleanup, and returns the filtered slice, a `blastRadius` (populated with `RemovedTask` values), a `RemovalResult`, and an error.\n4. Add a `computeOnly bool` parameter (or split into two functions): when true, the function validates and computes the blast radius but returns the original task slice unmodified; when false, it performs the full removal and returns the filtered slice.\n5. In `RunRemove`, for the non-force path: call `store.Mutate` with `computeOnly=true` to get the blast radius, show the confirmation prompt, then call `store.Mutate` again with `computeOnly=false` to perform the removal. For the force path: call `store.Mutate` once with `computeOnly=false`.\n6. Delete the `computeBlastRadius` function, the `idTitle` type, and the `database/sql` import (if no longer needed).\n7. Verify all existing tests pass without modification (the external behavior is unchanged).\n\n**Acceptance Criteria**:\n- `computeBlastRadius` function is removed\n- `idTitle` type is removed\n- No `database/sql` import in `remove.go` unless needed elsewhere\n- ID validation and descendant expansion exist in exactly one code path\n- The confirmation prompt (non-force path) still shows target tasks, cascaded descendants, and affected dependencies\n- All existing tests in `internal/cli` pass unchanged\n- Force and non-force paths produce identical removal results for the same inputs\n\n**Tests**:\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions in other commands\n- Verify force and non-force paths produce same output by comparing formatter output in existing test cases that test both paths","parent":"tick-d5946b","created":"2026-02-19T14:59:38Z","updated":"2026-02-19T15:06:25Z","closed":"2026-02-19T15:06:25Z"}
{"id":"tick-21f1ab","title":"Align RunRemove signature with handler convention","status":"done","priority":2,"description":"severity: medium\nsources: architecture\n\n**Problem**: Every `Run*` handler in the cli package follows the signature pattern `Run*(dir, fc, fmtr, args, stdout)` with 4-5 parameters. `RunRemove` takes 7 parameters (`dir`, `fc`, `fmtr`, `args`, `stdin`, `stderr`, `stdout`), breaking the uniform handler contract. The extra `stdin` and `stderr` parameters are needed for the interactive confirmation prompt but create an inconsistency that makes the handler harder to call and understand at a glance.\n\n**Solution**: Move the confirmation prompt logic into `handleRemove` on the `App` struct (which already has access to `a.Stdin` and `a.Stderr`), and slim `RunRemove` down to the standard 5-parameter signature. `RunRemove` should only handle the mutation and formatting -- not the interactive prompt. The `handleRemove` method computes the blast radius, runs the confirmation prompt using `a.Stdin`/`a.Stderr`, then calls `RunRemove` for the actual removal.\n\n**Outcome**: `RunRemove` conforms to the established `Run*(dir, fc, fmtr, args, stdout)` signature. The interactive prompt concern is separated from the mutation concern. The handler dispatch pattern in `app.go` remains consistent.\n\n**Do**:\n1. In `internal/cli/app.go`, expand `handleRemove` to: parse args (call `parseRemoveArgs`), open the store, compute the blast radius (if not force), run the confirmation prompt using `a.Stdin` and `a.Stderr`, then call `RunRemove`.\n2. Change `RunRemove` signature to `RunRemove(dir string, fc FormatConfig, fmtr Formatter, args []string, stdout io.Writer) error` -- matching other handlers. It receives pre-validated IDs (the force flag has already been handled), performs the Mutate, and formats output.\n3. Alternatively, if Task 1 has not been applied yet and `computeBlastRadius` still exists, `handleRemove` calls `computeBlastRadius` + `confirmRemovalWithCascade` before calling `RunRemove`. If Task 1 has been applied, `handleRemove` calls the dry-run Mutate + confirmation before calling `RunRemove` for the real Mutate.\n4. Update all call sites of `RunRemove` (only `handleRemove` in app.go).\n5. Update any tests that call `RunRemove` directly to use the new 5-parameter signature. Tests that need confirmation behavior should test via `App.Run` instead.\n6. Move `confirmRemovalWithCascade` call site to `handleRemove` or keep it in remove.go as a helper but remove `stdin`/`stderr` from `RunRemove`.\n\n**Acceptance Criteria**:\n- `RunRemove` signature matches `Run*(dir, fc, fmtr, args, stdout)` pattern\n- `RunRemove` has no `stdin` or `stderr` parameters\n- Interactive confirmation logic lives in `handleRemove` or a helper called from `handleRemove`\n- All existing tests pass\n- Force and non-force behavior unchanged\n\n**Tests**:\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions\n- Verify `RunRemove` can be called without stdin/stderr in tests that only need mutation behavior","parent":"tick-d5946b","created":"2026-02-19T14:59:59Z","updated":"2026-02-19T15:12:32Z","closed":"2026-02-19T15:12:32Z"}
{"id":"tick-9c6995","title":"Phase 5: Analysis (cycle 2)","status":"done","priority":2,"parent":"tick-132530","created":"2026-02-19T15:25:47Z","updated":"2026-02-19T15:35:27Z","closed":"2026-02-19T15:35:27Z"}
{"id":"tick-0c7c52","title":"Replace read-only Mutate with Store.ReadTasks and restructure handleRemove into a single-open flow","status":"done","priority":2,"description":"**Problem**: The non-force path in `handleRemove` (app.go:228-247) calls `store.Mutate` with `computeOnly=true` to compute the blast radius for the confirmation prompt. `Store.Mutate` always rewrites the JSONL file and rebuilds the SQLite cache regardless of whether the callback modifies the data (store.go:152-172). This means every non-forced remove rewrites the entire JSONL file unnecessarily before the user even sees the prompt. If the user declines, the file was rewritten for nothing -- and re-marshalling could introduce byte-level differences that change the file's MD5 hash and trigger unnecessary cache rebuilds. After the prompt, `handleRemove` delegates to `RunRemove` which opens the store a second time and runs `executeRemoval` again, creating a TOCTOU gap where another process could modify tasks between confirmation and execution. Additionally, `parseRemoveArgs` and the `len(ids)==0` check run twice (once in `handleRemove`, once in `RunRemove`), and the error message string `\"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\"` is duplicated verbatim. The `executeRemoval` function uses a `computeOnly bool` parameter to serve two fundamentally different purposes (read-only blast radius vs. actual removal), which is a boolean-parameter anti-pattern.\n\n**Solution**: (1) Add a `Store.ReadTasks` method that reads and parses the JSONL file under a shared lock without writing. (2) Split `executeRemoval` into two functions: `computeBlastRadius(tasks, ids)` for read-only blast radius computation and `applyRemoval(tasks, ids)` for the actual mutation. Both share internal helpers (`collectDescendants`, validation, `stripIDsFromBlockedBy`). (3) Restructure `handleRemove` so the non-force path uses `Store.ReadTasks` + `computeBlastRadius` for the prompt, then calls `RunRemove` once for the actual mutation. This eliminates the spurious Mutate rewrite, the double store open, the double executeRemoval, and the boolean parameter.\n\n**Outcome**: Non-forced removes no longer rewrite JSONL for the confirmation prompt. The store opens once for the read-only blast radius check (via `ReadTasks`) and once for the actual mutation (via `RunRemove`). No TOCTOU gap beyond the inherent confirmation pattern. `parseRemoveArgs` and ID validation run once in `handleRemove`, with pre-parsed IDs passed to `RunRemove`. Each function has a single responsibility. The `computeOnly` parameter is eliminated.\n\n**Do**:\n1. In `internal/storage/store.go`, add a `ReadTasks` method:\n   ```go\n   func (s *Store) ReadTasks() ([]task.Task, error) {\n       unlock, err := s.acquireShared()\n       if err \\!= nil {\n           return nil, err\n       }\n       defer unlock()\n       _, tasks, err := s.readAndEnsureFresh()\n       if err \\!= nil {\n           return nil, err\n       }\n       return tasks, nil\n   }\n   ```\n   This provides read-only access to the in-memory task slice without writing.\n2. In `internal/cli/remove.go`, split `executeRemoval` into two functions:\n   - `computeBlastRadius(tasks []task.Task, ids []string) (blastRadius, error)` -- validates all IDs exist, expands descendants via `collectDescendants`, identifies cascaded tasks and affected deps. Returns a populated `blastRadius` struct.\n   - `applyRemoval(tasks []task.Task, ids []string) ([]task.Task, RemovalResult, error)` -- validates all IDs exist, expands descendants, filters removed tasks from the slice, cleans up `BlockedBy` arrays on surviving tasks, returns the filtered slice and `RemovalResult`.\n   - Both functions call shared helpers for validation and descendant expansion. Extract the common ID-validation loop and descendant expansion into a helper like `validateAndExpand(tasks, ids) (targetSet, removeSet, existingIDs map, error)` if the duplication between the two new functions warrants it.\n3. Delete the `executeRemoval` function.\n4. Update `RunRemove` to:\n   - Accept pre-parsed IDs instead of raw args. Change signature to `RunRemove(dir string, fc FormatConfig, fmtr Formatter, ids []string, stdout io.Writer) error`. Remove the `parseRemoveArgs` call and `len(ids)==0` check from `RunRemove` (these now live only in `handleRemove`).\n   - Call `store.Mutate` with `applyRemoval` (no `computeOnly` flag).\n5. Update `handleRemove` in `internal/cli/app.go`:\n   - Parse args once: `ids, force := parseRemoveArgs(subArgs)`. Validate `len(ids)==0` once.\n   - Non-force path: open store via `openStore`, call `store.ReadTasks()` to get the task slice, call `computeBlastRadius(tasks, ids)`, close the store, run `confirmRemovalWithCascade`, then call `RunRemove(dir, fc, fmtr, ids, a.Stdout)`.\n   - Force path: call `RunRemove(dir, fc, fmtr, ids, a.Stdout)` directly.\n6. Update all tests that call `RunRemove` directly to pass pre-parsed ID slices instead of raw arg slices. If any tests pass `--force` in args to `RunRemove`, adjust them to pass only IDs since force handling is now in `handleRemove`.\n7. Verify `go test ./internal/cli -count=1` and `go test ./internal/storage -count=1` pass.\n\n**Acceptance Criteria**:\n- `Store.ReadTasks` method exists and uses shared (not exclusive) locking\n- `executeRemoval` function with `computeOnly bool` parameter no longer exists\n- `computeBlastRadius` and `applyRemoval` are separate functions with distinct return types\n- `RunRemove` signature matches the `Run*(dir, fc, fmtr, args/ids, stdout)` pattern with no raw-arg parsing\n- `parseRemoveArgs` and the empty-ID validation run exactly once per invocation (in `handleRemove`)\n- The error message `\"task ID is required. Usage: tick remove \u003cid\u003e [\u003cid\u003e...]\"` appears exactly once in the codebase\n- Non-force path does not call `Store.Mutate` for blast radius computation\n- All existing tests pass\n- Force and non-force paths produce identical removal results for the same inputs\n\n**Tests**:\n- Run `go test ./internal/storage -run TestReadTasks -count=1` (new test for ReadTasks method) -- returns correct task slice without modifying JSONL file\n- Run `go test ./internal/cli -run TestRemove -count=1` -- all existing remove tests pass\n- Run `go test ./internal/cli -count=1` -- no regressions in other commands\n- Run `go test ./... -count=1` -- full suite passes\n- Verify JSONL file is not rewritten during non-force blast radius computation by checking file modification time or content hash in a test","parent":"tick-9c6995","created":"2026-02-19T15:26:31Z","updated":"2026-02-19T15:35:27Z","closed":"2026-02-19T15:35:27Z"}
{"id":"tick-e679e0","title":"Blocked Ancestor Ready","status":"done","priority":2,"created":"2026-02-20T14:02:29Z","updated":"2026-02-20T15:44:44Z","closed":"2026-02-20T15:44:44Z"}
{"id":"tick-3cf896","title":"Phase 1: Blocked Ancestor Ready Check","status":"done","priority":2,"parent":"tick-e679e0","created":"2026-02-20T14:02:50Z","updated":"2026-02-20T15:30:43Z","closed":"2026-02-20T15:30:43Z"}
{"id":"tick-fb9d84","title":"Add ReadyNoBlockedAncestor helper and integrate into ReadyConditions","status":"done","priority":2,"description":"Problem: Children and deeper descendants of dependency-blocked ancestors incorrectly appear as \"ready\" because ReadyConditions() only checks the task's own blockers and children -- never walks up the parent chain.\n\nSolution: Add ReadyNoBlockedAncestor() helper with recursive CTE in query_helpers.go, integrate as 4th condition in ReadyConditions(). All consumers automatically pick up the change.\n\nOutcome: ReadyConditions() includes ancestor-chain dependency checking so that no descendant of a dependency-blocked ancestor appears in ready results, with all existing ready consumers (list --ready, tick ready, stats) automatically inheriting the fix.\n\nDo:\n1. In internal/cli/query_helpers.go, add ReadyNoBlockedAncestor() string returning NOT EXISTS + recursive CTE SQL fragment per spec template. CTE walks unconditionally to root via parent pointers, joins dependencies+tasks to check for unclosed blockers (blocker.status NOT IN ('done','cancelled')).\n2. In ReadyConditions(), append ReadyNoBlockedAncestor() as the 4th element.\n3. Update unit test in query_helpers_test.go: expect len(conditions)==4, verify conditions[3]==ReadyNoBlockedAncestor(). Add subtest for non-empty helper output.\n4. Add integration tests in internal/cli/ready_test.go covering: child of blocked parent excluded, grandchild excluded, intermediate grouping task descendant excluded, ancestor blocker resolved restores readiness, root task unaffected.\n5. Verify ReadyWhereClause() automatically includes the new condition (no changes needed).\n\nAcceptance Criteria:\n- ReadyNoBlockedAncestor() returns non-empty NOT EXISTS with recursive CTE\n- ReadyConditions() returns 4 conditions, 4th is ReadyNoBlockedAncestor()\n- ReadyWhereClause() output includes ancestor check automatically\n- Child of dependency-blocked parent excluded from tick ready\n- Grandchild of blocked grandparent (clean intermediate parent) excluded\n- Descendant behind intermediate grouping task under blocked ancestor excluded\n- Ancestor blocker resolved -\u003e descendants ready again\n- Root tasks with no parent unaffected\n- All existing tests pass (updated count in query_helpers_test.go)\n\nTests:\n- \"it provides a non-empty no-blocked-ancestor condition\" (unit)\n- \"ReadyConditions returns status open plus all four conditions\" (unit)\n- \"it excludes child of dependency-blocked parent from ready\" (integration)\n- \"it excludes grandchild of dependency-blocked grandparent from ready\" (integration)\n- \"it excludes descendant behind intermediate grouping task under blocked ancestor\" (integration)\n- \"it includes descendant when ancestor blocker is resolved\" (integration)\n- \"it does not affect root task with no parent\" (integration)\n\nEdge Cases: grandchild chain, intermediate grouping task, root task, blocker resolution, closed ancestors in chain\n\nSpec Reference: docs/workflow/specification/blocked-ancestor-ready/specification.md","parent":"tick-3cf896","created":"2026-02-20T14:03:06Z","updated":"2026-02-20T15:22:47Z","closed":"2026-02-20T15:22:47Z"}
{"id":"tick-52f1cf","title":"Add blocked-ancestor EXISTS condition to BlockedConditions","status":"done","priority":2,"description":"Problem: Tasks blocked due to a dependency-blocked ancestor do not appear in tick list --blocked or tick blocked output. After Task 1 adds the ancestor check to ReadyConditions(), these tasks fall into a gap -- excluded from both ready and blocked results.\n\nSolution: Add the EXISTS inverse of the ancestor CTE to the BlockedConditions() OR clause in query_helpers.go. This is the De Morgan complement of ReadyNoBlockedAncestor(): NOT EXISTS becomes EXISTS with the same recursive CTE.\n\nOutcome: BlockedConditions() includes ancestor-blocker detection so that descendants of dependency-blocked ancestors appear in blocked results, closing the gap between ready and blocked filters with stats counts remaining consistent.\n\nDo:\n1. In internal/cli/query_helpers.go, update BlockedConditions(). Add a third OR branch to the second condition: EXISTS ( WITH RECURSIVE ancestors(id) AS (...) SELECT 1 FROM ancestors a JOIN dependencies d ON d.task_id = a.id JOIN tasks blocker ON blocker.id = d.blocked_by WHERE blocker.status NOT IN ('done','cancelled') ). Full second condition becomes: (EXISTS own-blockers OR EXISTS open-children OR EXISTS ancestor-blocker).\n2. Update unit test in query_helpers_test.go: verify conditions[1] contains \"ancestors\" substring.\n3. Add integration tests in internal/cli/blocked_test.go: child of blocked parent appears in blocked, grandchild appears in blocked, intermediate grouping task descendant appears in blocked, ancestor blocker resolved removes from blocked, stats count consistency (ready count matches list --ready).\n4. Verify existing blocked tests still pass.\n\nAcceptance Criteria:\n- BlockedConditions() second condition contains three OR branches (own blockers, open children, ancestor blocker)\n- Child of dependency-blocked parent appears in tick blocked / list --blocked\n- Grandchild of blocked grandparent appears in blocked output\n- Ancestor blocker resolved -\u003e descendants no longer in blocked output\n- Stats ready count matches list --ready count for mixed scenario\n- All existing tests pass\n\nTests:\n- \"it returns child of dependency-blocked parent in blocked\" (integration)\n- \"it returns grandchild of dependency-blocked grandparent in blocked\" (integration)\n- \"it returns descendant behind intermediate grouping task under blocked ancestor in blocked\" (integration)\n- \"it excludes descendant from blocked when ancestor blocker resolved\" (integration)\n- \"it maintains stats count consistency with blocked ancestors\" (integration)\n- \"BlockedConditions includes ancestor blocker in OR clause\" (unit)\n\nEdge Cases: grandchild in blocked, intermediate grouping task in blocked, blocker resolution removes from blocked, stats consistency, existing blocked tasks unaffected\n\nSpec Reference: docs/workflow/specification/blocked-ancestor-ready/specification.md","blocked_by":["tick-fb9d84"],"parent":"tick-3cf896","created":"2026-02-20T14:03:21Z","updated":"2026-02-20T15:30:35Z","closed":"2026-02-20T15:30:35Z"}
{"id":"tick-884d97","title":"Phase 2: Analysis (Cycle 1)","status":"done","priority":2,"parent":"tick-e679e0","created":"2026-02-20T15:36:22Z","updated":"2026-02-20T15:44:44Z","closed":"2026-02-20T15:44:44Z"}
{"id":"tick-cbdae7","title":"Compose BlockedConditions() from ReadyNo*() helpers instead of duplicating SQL","status":"done","priority":2,"description":"**Problem**: `BlockedConditions()` in `internal/cli/query_helpers.go` (lines 64-94) contains three independently-written EXISTS subqueries whose SQL bodies are character-for-character identical to the NOT EXISTS subqueries returned by `ReadyNoUnclosedBlockers()`, `ReadyNoOpenChildren()`, and `ReadyNoBlockedAncestor()`. Only the EXISTS vs NOT EXISTS wrapper differs. This violates the project's \"Compose, Don't Duplicate\" principle: if any ReadyNo*() helper is modified, BlockedConditions() must be manually updated in lockstep or it silently drifts.\n\n**Solution**: Refactor `BlockedConditions()` to derive its OR clause from the existing ReadyNo*() helpers by mechanically negating them -- stripping the leading \"NOT \" from each helper's output to convert `NOT EXISTS (...)` into `EXISTS (...)`. This eliminates ~25 lines of duplicated SQL and guarantees the two stay in sync.\n\n**Outcome**: `BlockedConditions()` contains zero hand-written SQL subquery bodies. All SQL logic lives exclusively in the ReadyNo*() helpers, and `BlockedConditions()` composes from them. Any future change to a ready helper automatically propagates to blocked logic.\n\n**Do**:\n1. In `internal/cli/query_helpers.go`, add a small unexported helper function (e.g., `negateNotExists(s string) string`) that takes a `NOT EXISTS (...)` string and returns the `EXISTS (...)` form by stripping the leading `\"NOT \"` prefix via `strings.TrimPrefix` or `strings.CutPrefix`.\n2. Rewrite `BlockedConditions()` to build its OR clause by calling `negateNotExists()` on each of `ReadyNoUnclosedBlockers()`, `ReadyNoOpenChildren()`, and `ReadyNoBlockedAncestor()`, joining the results with `\"\\n\\t\\t\\t\\tOR \"` and wrapping in parentheses.\n3. Delete the three hand-written EXISTS subquery blocks currently in `BlockedConditions()`.\n4. Run `go test ./internal/cli/...` to confirm all existing ready, blocked, list, and stats tests still pass.\n5. Verify with `go vet ./...` and `gofmt -d ./internal/cli/query_helpers.go` that the code is clean.\n\n**Acceptance Criteria**:\n- `BlockedConditions()` contains no SQL string literals other than `t.status = 'open'`\n- `BlockedConditions()` calls all three `ReadyNo*()` helpers (directly or via negation)\n- All existing tests in `internal/cli/` pass without modification\n- `go vet ./...` reports no issues\n\n**Tests**:\n- Add a unit test in `internal/cli/query_helpers_test.go` that verifies `BlockedConditions()` output contains the same subquery bodies as the negated `ReadyNo*()` helpers (e.g., confirm each ReadyNo*() body appears in the BlockedConditions output with EXISTS instead of NOT EXISTS). This acts as a drift-detection test.","parent":"tick-884d97","created":"2026-02-20T15:36:42Z","updated":"2026-02-20T15:44:37Z","closed":"2026-02-20T15:44:37Z"}
{"id":"tick-db58ad","title":"CLI Enhancements","status":"open","priority":2,"created":"2026-02-28T08:46:48Z","updated":"2026-02-28T08:46:48Z"}
{"id":"tick-bc42b5","title":"Phase 1: Partial ID Matching","status":"open","priority":2,"parent":"tick-db58ad","created":"2026-02-28T08:46:51Z","updated":"2026-02-28T08:46:51Z"}
{"id":"tick-9283bb","title":"ResolveID method in storage layer","status":"open","priority":2,"description":"Problem: Users must type the full 10-character task ID (tick-a3f1b2) for every command. No mechanism in the storage layer to resolve a prefix to a full ID.\n\nSolution: Add ResolveID(prefix string) (string, error) method to storage.Store that accepts raw user input (with or without tick- prefix, any case), normalizes it, and queries the SQLite cache to resolve to a single full task ID. Exact full-ID match bypasses prefix search, minimum 3 hex chars for prefix matching, ambiguity errors listing matching IDs, not-found errors.\n\nOutcome: Store.ResolveID is a tested, self-contained method that downstream commands call to convert any user-supplied ID input into a canonical full ID. All edge cases covered by unit tests.\n\nDo:\n- In internal/storage/store.go, add public method ResolveID(input string) (string, error) on *Store\n- Strip tick- prefix if present (case-insensitive), lowercase remaining hex portion\n- If normalized input is exactly 6 hex chars, query SELECT id FROM tasks WHERE id = 'tick-{input}'. If found, return immediately (exact match bypass)\n- If normalized prefix \u003c 3 chars, return error: \"partial ID must be at least 3 hex characters\"\n- If 3-5 chars (or 6-char with no exact match), prefix query: SELECT id FROM tasks WHERE id LIKE 'tick-{prefix}%' via Store.Query()\n- Zero rows: return fmt.Errorf(\"task '%s' not found\", original_input)\n- One row: return matched full ID\n- 2+ rows: return error listing all matching IDs\n- Add tests in internal/storage/resolve_id_test.go\n\nAcceptance Criteria:\n- ResolveID(\"a3f\") returns full ID when exactly one task matches tick-a3f*\n- ResolveID(\"tick-a3f\") returns same result (tick- prefix stripped)\n- ResolveID(\"A3F\") returns same result (case-insensitive)\n- ResolveID(\"TICK-A3F\") returns same result (tick- prefix + case-insensitive)\n- ResolveID(\"tick-a3f1b2\") returns tick-a3f1b2 immediately even if tick-a3f1b3 exists\n- ResolveID(\"ab\") returns minimum 3 hex chars error\n- ResolveID(\"a3f\") returns ambiguity error listing both IDs when two tasks match\n- ResolveID(\"zzz\") returns not-found error\n- Method uses Store.Query() internally\n\nTests:\n- \"it resolves a unique 3-char prefix to the full ID\"\n- \"it strips tick- prefix before matching\"\n- \"it normalizes input to lowercase\"\n- \"it strips tick- prefix case-insensitively (TICK-A3F)\"\n- \"it returns exact full ID immediately without ambiguity check\"\n- \"it errors when prefix is shorter than 3 hex chars\"\n- \"it errors when prefix is 1 hex char\"\n- \"it errors with ambiguous prefix listing all matching IDs\"\n- \"it errors with not found for non-matching prefix\"\n- \"it resolves a 4-char prefix uniquely\"\n- \"it resolves a 5-char prefix uniquely\"\n- \"it falls back to prefix search when 6-char input has no exact match\"\n\nEdge Cases:\n- Prefix \u003c 3 hex chars after stripping tick-: error. Applies to \"ab\", \"tick-ab\", \"a\", \"\"\n- Ambiguous prefix 2+ tasks: error must list all matching full IDs\n- Exact full-ID bypass: 6-hex-char exact match returns immediately even if others share prefix\n- Mixed-case input (TICK-A3F, Tick-a3F1B2): all normalized to lowercase\n- tick- prefix stripping: handle both tick-abc and abc identically; prefix check case-insensitive\n\nContext:\n- Method lives on Store and uses Store.Query() because ID resolution needs fresh SQLite cache\n- tasks table has id TEXT PRIMARY KEY supporting both exact and LIKE queries\n- Task IDs always tick-{6 hex chars} from task.GenerateID, hex always lowercase in storage\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md — Partial ID Matching section","parent":"tick-bc42b5","created":"2026-02-28T08:47:08Z","updated":"2026-02-28T08:47:08Z"}
{"id":"tick-b45af0","title":"Integrate ResolveID into positional ID commands","status":"open","priority":2,"description":"Problem: Commands taking a positional task ID (show, start, done, cancel, reopen, remove) call task.NormalizeID() with no prefix resolution. Users must type full IDs.\n\nSolution: Replace task.NormalizeID(args[0]) with store.ResolveID(args[0]) in each handler after store is opened. The rest of the command proceeds with the full canonical ID as before.\n\nOutcome: Users can type tick show a3f, tick start a3f, etc. using any unambiguous prefix. All existing full-ID usage continues unchanged.\n\nDo:\n- show.go — RunShow: Move store open before ID resolution. Replace id := task.NormalizeID(args[0]) with id, err := store.ResolveID(args[0])\n- transition.go — RunTransition: Same pattern — resolve after store open\n- remove.go — handleRemove in app.go: Parse raw args without normalizing, open store, resolve each ID via store.ResolveID, then proceed with blast radius and RunRemove. parseRemoveArgs collects raw positional args; resolution happens after store is open. RunRemove itself does not need changes — it receives resolved full IDs.\n- Add integration tests in internal/cli/ exercising each command with a partial ID\n\nAcceptance Criteria:\n- tick show a3f displays the task detail for the matching task\n- tick start a3f transitions the matching task to in_progress\n- tick done a3f transitions the matching task to done\n- tick cancel a3f transitions the matching task to cancelled\n- tick reopen a3f transitions the matching task back to open\n- tick remove a3f --force removes the matching task\n- All commands still work with full IDs (tick show tick-a3f1b2)\n- Ambiguous prefix errors propagate correctly to stderr\n- Not-found prefix errors propagate correctly to stderr\n\nTests:\n- \"it shows a task using a 3-char partial ID\"\n- \"it transitions a task using a partial ID (start)\"\n- \"it transitions a task using a partial ID (done)\"\n- \"it transitions a task using a partial ID (cancel)\"\n- \"it transitions a task using a partial ID (reopen)\"\n- \"it removes a task using a partial ID with --force\"\n- \"it removes multiple tasks using partial IDs\"\n- \"it errors with ambiguous prefix on show\"\n- \"it errors with not found prefix on start\"\n- \"it still works with full IDs on all commands\"\n\nEdge Cases:\n- None beyond those covered by ResolveID itself (Task 1). Straightforward plumbing.\n\nContext:\n- The remove command has a two-phase flow: store open for blast radius (read-only), then store open for mutation in RunRemove. ID resolution should happen once, before either phase.\n- Current pattern: id := task.NormalizeID(args[0]) then use id throughout. New pattern: id, err := store.ResolveID(args[0]) then use id throughout.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md — Partial ID Matching section, Implementation location subsection","parent":"tick-bc42b5","created":"2026-02-28T08:47:49Z","updated":"2026-02-28T08:47:49Z"}
{"id":"tick-9540a5","title":"Integrate ResolveID into update and create ID-referencing flags","status":"open","priority":2,"description":"Problem: The update command accepts --parent and --blocks flags that reference task IDs, and create accepts --parent, --blocked-by, --blocks. These use task.NormalizeID() or parseCommaSeparatedIDs() without prefix resolution. Users must type full IDs.\n\nSolution: After opening the store but before mutations, resolve every ID-referencing flag value through store.ResolveID(). For update: positional ID, --parent, each --blocks entry. For create: --parent, each --blocked-by, each --blocks. Resolution happens after flag parsing but before store.Mutate().\n\nOutcome: Users can use partial IDs in all flags on update and create. Self-reference validation works correctly on fully resolved IDs.\n\nDo:\n- update.go — RunUpdate: After openStore, resolve opts.id, *opts.parent (if non-empty), and each opts.blocks entry via store.ResolveID. Update parseUpdateArgs to stop calling task.NormalizeID() — collect raw input.\n- create.go — RunCreate: After openStore, resolve opts.parent, each opts.blockedBy, each opts.blocks via store.ResolveID. Update parseCreateArgs similarly.\n- helpers.go — parseCommaSeparatedIDs: Currently calls task.NormalizeID() on each part. Simplify to trim+filter only; let ResolveID handle normalization. Double-lowercasing is harmless if kept.\n- Add tests verifying partial IDs in --parent, --blocked-by, --blocks on both create and update.\n\nAcceptance Criteria:\n- tick update a3f --title \"new title\" resolves the positional ID\n- tick update tick-a3f1b2 --parent b2c resolves --parent value\n- tick update tick-a3f1b2 --blocks b2c,c1d resolves each --blocks value\n- tick create \"task\" --parent a3f resolves --parent value\n- tick create \"task\" --blocked-by a3f,b2c resolves each --blocked-by value\n- tick create \"task\" --blocks a3f resolves --blocks value\n- Self-reference detection still works: tick update a3f --parent a3f errors\n- Ambiguous partial in flag value produces clear error\n- Not-found partial in flag value produces clear error\n\nTests:\n- \"it updates a task using partial ID as positional arg\"\n- \"it resolves partial ID in --parent flag on update\"\n- \"it resolves partial IDs in --blocks flag on update\"\n- \"it resolves partial ID in --parent flag on create\"\n- \"it resolves partial IDs in --blocked-by flag on create\"\n- \"it resolves partial IDs in --blocks flag on create\"\n- \"it detects self-reference when partial --parent resolves to same task on update\"\n- \"it errors on ambiguous partial in --blocked-by on create\"\n- \"it errors on not-found partial in --parent on update\"\n\nEdge Cases:\n- Partial --parent resolving to the task itself (self-reference): check runs after resolution comparing fully resolved IDs. For update, compare resolved positional ID with resolved --parent. For create, self-reference structurally impossible (new task ID generated inside Mutate).\n- --blocks on create: self-blocking structurally impossible since new ID doesn't exist yet.\n\nContext:\n- In create.go, --parent/--blocked-by/--blocks parsed in parseCreateArgs, validated in store.Mutate() via validateRefs(). Resolution must happen between parse and mutate.\n- In update.go, --parent normalized in parseUpdateArgs, --blocks via parseCommaSeparatedIDs. Both need resolution after store open.\n- parseCommaSeparatedIDs in helpers.go shared between create and update. Cleaner to keep it doing trim+filter only and let ResolveID handle all normalization.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md — Partial ID Matching section, Implementation location subsection","parent":"tick-bc42b5","created":"2026-02-28T08:48:17Z","updated":"2026-02-28T08:48:17Z"}
{"id":"tick-376da0","title":"Integrate ResolveID into dep add/rm","status":"open","priority":2,"description":"Problem: dep add and dep rm accept two positional task IDs (task_id, blocked_by_id). Normalized via task.NormalizeID() in parseDepArgs but no prefix resolution. Users must type full IDs.\n\nSolution: After opening the store in RunDepAdd and RunDepRm, resolve both positional IDs through store.ResolveID() before the mutation. parseDepArgs returns raw (or lowercased) values; resolution happens after store is available.\n\nOutcome: Users can type tick dep add a3f b2c and tick dep rm a3f b2c using any unambiguous prefix. Both arguments resolving to the same task produces a self-dependency error from existing ValidateDependency.\n\nDo:\n- dep.go — RunDepAdd: After openStore, resolve taskID via store.ResolveID(taskID) and blockedByID via store.ResolveID(blockedByID). Handle errors from either resolution. Resolved full IDs flow into existing Mutate callback.\n- dep.go — RunDepRm: Same pattern — resolve both IDs after store open.\n- dep.go — parseDepArgs: Currently calls task.NormalizeID() on both positional args. Keep (harmless double-lowercasing) or simplify to trim. Resolution happens after parseDepArgs returns and after store is open.\n- Add tests verifying partial IDs for both arguments in dep add and dep rm.\n\nAcceptance Criteria:\n- tick dep add a3f b2c adds a dependency using partial IDs for both arguments\n- tick dep rm a3f b2c removes a dependency using partial IDs\n- tick dep add tick-a3f1b2 b2c mixes full and partial IDs\n- Both arguments resolving to same full ID produces self-dependency error\n- Ambiguous partial in either argument produces clear error\n- Not-found partial in either argument produces clear error\n- Full IDs continue to work as before\n\nTests:\n- \"it adds a dependency using partial IDs for both args\"\n- \"it removes a dependency using partial IDs for both args\"\n- \"it resolves mixed full and partial IDs in dep add\"\n- \"it errors when both partial IDs resolve to the same task\"\n- \"it errors with ambiguous prefix in first arg of dep add\"\n- \"it errors with ambiguous prefix in second arg of dep add\"\n- \"it errors with not-found prefix in dep rm\"\n- \"it still works with full IDs in dep add\"\n- \"it still works with full IDs in dep rm\"\n\nEdge Cases:\n- Both arguments resolving to same task: tick dep add a3f a3f where both resolve to tick-a3f1b2. Existing ValidateDependency catches self-reference. No new validation needed.\n\nContext:\n- dep add and dep rm in dep.go follow consistent pattern: parseDepArgs extracts two positional IDs, then Run* opens store, finds tasks by ID in Mutate callback, applies change. Resolution slots in between parse and mutate.\n- Existing ValidateDependency in internal/task/ handles self-reference, cycle detection, child-blocked-by-parent validation — all operate on full IDs and work correctly after resolution.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md — Partial ID Matching section, Implementation location subsection","parent":"tick-bc42b5","created":"2026-02-28T08:48:48Z","updated":"2026-02-28T08:48:48Z"}
{"id":"tick-ccdecb","title":"Phase 2: Task Types and List Count","status":"open","priority":2,"parent":"tick-db58ad","created":"2026-02-28T10:26:25Z","updated":"2026-02-28T10:26:25Z"}
{"id":"tick-5a322f","title":"Add Type field to Task model and JSONL serialization","status":"open","priority":2,"description":"Problem: The Task struct has no Type field, so users cannot classify tasks as bug, feature, task, or chore.\n\nSolution: Add Type string field to Task struct with omitempty JSON serialization, plus validation and normalization functions for the closed set (bug, feature, task, chore).\n\nOutcome: Task struct includes Type field that round-trips through JSON correctly, with validation functions covering all edge cases.\n\nDo:\n1. In internal/task/task.go, add Type string with json:\"type,omitempty\" tag. Add to taskJSON struct. Update MarshalJSON/UnmarshalJSON to copy the field.\n2. Add ValidateType(typ string) error -- checks one of bug/feature/task/chore. Empty string valid (optional).\n3. Add NormalizeType(typ string) string -- trims whitespace, lowercases.\n4. Add ValidateTypeNotEmpty(typ string) error -- for --type flag context, errors on empty/whitespace with message pointing to --clear-type.\n5. Tests in internal/task/task_test.go.\n\nAcceptance Criteria:\n- Task.Type field with json:\"type,omitempty\" tag\n- MarshalJSON includes type when non-empty, omits when empty\n- UnmarshalJSON populates Type from JSON\n- ValidateType(\"\") returns nil; valid values return nil; invalid returns error listing allowed values\n- NormalizeType(\"  BUG  \") returns \"bug\"\n- ValidateTypeNotEmpty(\"\") returns error mentioning --clear-type\n- Backward compatible: existing tasks without type deserialize with empty Type\n\nTests:\n- \"it marshals type field when set\"\n- \"it omits type field when empty\"\n- \"it unmarshals type field from JSON\"\n- \"it unmarshals task without type field (backward compat)\"\n- \"it validates allowed type values\"\n- \"it rejects invalid type value\"\n- \"it allows empty type (optional field)\"\n- \"it normalizes type input to trimmed lowercase\"\n- \"it rejects empty string on --type flag context\"\n- \"it rejects whitespace-only input on --type flag context\"\n- \"it rejects mixed-case invalid type after normalization\"\n\nEdge Cases:\n- Empty --type: ValidateTypeNotEmpty catches with message pointing to --clear-type\n- Mixed-case input: NormalizeType lowercases before validation\n- Invalid type value: ValidateType returns error with allowed values list\n- Whitespace-only: NormalizeType trims to empty, ValidateTypeNotEmpty catches\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Task Types section","parent":"tick-ccdecb","created":"2026-02-28T10:26:49Z","updated":"2026-02-28T10:26:49Z"}
{"id":"tick-9e1481","title":"Add Type column to SQLite schema and Cache.Rebuild","status":"open","priority":2,"description":"Problem: SQLite cache schema has no type column. The new Type field cannot be queried or filtered via SQL.\n\nSolution: Add type TEXT column to tasks table in schemaSQL and update Cache.Rebuild to insert Type value for each task.\n\nOutcome: After cache rebuild, every task row has type column populated (NULL when unset). Schema migration via CREATE TABLE IF NOT EXISTS on fresh databases. Existing caches rebuilt from JSONL.\n\nDo:\n1. In internal/storage/cache.go, update schemaSQL: add type TEXT column after description.\n2. Update Rebuild INSERT statement to include type column.\n3. Handle type value same as description: *string pointer, nil when empty.\n4. Tests in internal/storage/cache_test.go.\n\nAcceptance Criteria:\n- schemaSQL includes type TEXT column\n- Cache.Rebuild inserts type value; empty -\u003e NULL, set -\u003e stored value\n- Fresh cache opens correctly with new schema\n- Existing test suite passes\n\nTests:\n- \"it stores type value in SQLite after rebuild\"\n- \"it stores NULL for empty type after rebuild\"\n\nEdge Cases: None -- mechanical schema change.\n\nContext: SQLite cache is expendable, rebuilt from JSONL via SHA256 hash comparison. CREATE TABLE IF NOT EXISTS means fresh databases get new column automatically.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Task Types section, Storage subsection","parent":"tick-ccdecb","created":"2026-02-28T10:27:00Z","updated":"2026-02-28T10:27:00Z"}
{"id":"tick-811654","title":"Create and update commands with --type and --clear-type flags","status":"open","priority":2,"description":"Problem: create and update commands do not support --type or --clear-type. Users cannot assign or modify type classification.\n\nSolution: Add --type flag parsing to parseCreateArgs and parseUpdateArgs, --clear-type to parseUpdateArgs, wire validation into RunCreate and RunUpdate, apply type during mutation.\n\nOutcome: Users can run tick create \"Fix login\" --type bug and tick update \u003cid\u003e --type feature to set types, tick update \u003cid\u003e --clear-type to remove. Mutual exclusivity enforced.\n\nDo:\n1. create.go: Add taskType string to createOpts. Parse --type in parseCreateArgs. In RunCreate, normalize+validate, set newTask.Type.\n2. update.go: Add taskType *string and clearType bool to updateOpts. Update hasChanges(). Parse --type and --clear-type.\n3. RunUpdate: Mutual exclusivity check (both set -\u003e error). Normalize+validate --type.\n4. Mutation: --clear-type -\u003e Type=\"\"; --type -\u003e normalized value.\n5. Integration tests in create_test.go and update_test.go.\n\nAcceptance Criteria:\n- tick create \"Fix login\" --type bug creates with Type=\"bug\"\n- tick create \"Add feature\" --type FEATURE normalizes to \"feature\"\n- tick create with empty/invalid --type errors\n- tick create without --type leaves type empty (optional)\n- tick update \u003cid\u003e --type chore sets type\n- tick update \u003cid\u003e --clear-type removes type\n- tick update \u003cid\u003e --type bug --clear-type errors (mutually exclusive)\n- Type persists in JSONL\n- hasChanges() correct for --type and --clear-type\n\nTests:\n- \"it creates a task with --type bug\"\n- \"it creates a task with --type normalized from uppercase\"\n- \"it creates a task without --type (optional)\"\n- \"it errors on create with empty --type value\"\n- \"it errors on create with invalid --type value\"\n- \"it errors on create with whitespace-only --type\"\n- \"it updates task type with --type chore\"\n- \"it clears task type with --clear-type\"\n- \"it errors on update with --type and --clear-type together\"\n- \"it errors on update with empty --type value\"\n\nEdge Cases:\n- --type and --clear-type together: mutually exclusive error\n- Empty --type: ValidateTypeNotEmpty catches, points to --clear-type\n- Whitespace-only: normalized to empty, then caught\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Task Types section, CLI flags subsection","parent":"tick-ccdecb","created":"2026-02-28T10:27:15Z","updated":"2026-02-28T10:27:15Z"}
{"id":"tick-3357ef","title":"List/ready/blocked filtering by --type","status":"open","priority":2,"description":"Problem: list, ready, and blocked commands do not support filtering by task type.\n\nSolution: Add Type field to ListFilter, parse --type in parseListFlags with normalization and validation, include t.type = ? SQL condition in buildListQuery. Also expand listRow and SQL SELECT to include the type column for formatter consumption.\n\nOutcome: Users can run tick list --type bug, tick ready --type feature, tick blocked --type chore. Invalid type values produce clear errors. Works with all existing filters.\n\nDo:\n1. Add Type string to ListFilter struct.\n2. In parseListFlags, parse --type: normalize with task.NormalizeType, validate with task.ValidateType.\n3. In buildListQuery, if f.Type \\!= \"\", append t.type = ? to conditions.\n4. Update SQL SELECT to include t.type column. Add taskType (*string for nullable) to listRow. Scan type value. Set Task.Type from scanned value (empty if NULL).\n5. Tests for filter parsing and end-to-end filtering.\n\nAcceptance Criteria:\n- tick list --type bug returns only type=bug tasks\n- tick list --type BUG normalizes to bug and filters correctly\n- tick list --type epic returns error with allowed values\n- tick ready --type feature and tick blocked --type chore filter correctly\n- Combines with existing filters (--status, --priority)\n- No matches returns empty list, not error\n- Type data available in []task.Task slice for formatters\n\nTests:\n- \"it filters list by --type bug\"\n- \"it normalizes --type filter input to lowercase\"\n- \"it errors on invalid --type filter value\"\n- \"it returns empty list when no tasks match --type filter\"\n- \"it filters ready tasks by --type\"\n- \"it filters blocked tasks by --type\"\n- \"it combines --type with --status filter\"\n- \"it combines --type with --priority filter\"\n- \"it returns all tasks when --type not specified\"\n- \"it errors when --type flag has no value\"\n\nEdge Cases:\n- Invalid type in filter: validation error with allowed values list\n- No matching tasks: empty list, not error\n- Normalized filter matching: --type BUG matches stored \"bug\"\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Task Types section, Filtering subsection","parent":"tick-ccdecb","created":"2026-02-28T10:27:29Z","updated":"2026-02-28T10:27:29Z"}
{"id":"tick-2a23a5","title":"Display Type in list and show output across all formatters","status":"open","priority":2,"description":"Problem: The three formatters (Toon, Pretty, JSON) do not display task type in list or show output.\n\nSolution: Update all three formatter implementations to include type in list output (column between Priority and Title) and show/detail output. Dash (-) when unset in Pretty list.\n\nOutcome: List output shows TYPE column/field. Show output includes type. Unset types display as dash in Pretty, empty in Toon/JSON.\n\nDo:\n1. PrettyFormatter (pretty_formatter.go):\n   - FormatTaskList: Add TYPE column between PRI and TITLE. Compute typeWidth dynamically. Empty Type -\u003e \"-\".\n   - FormatTaskDetail: Add Type: line after Priority. Empty -\u003e \"-\".\n2. ToonFormatter (toon_formatter.go):\n   - Update toonTaskRow: add Type field.\n   - FormatTaskList: populate Type from each task.\n   - buildTaskSection (FormatTaskDetail): add type field, include only if non-empty.\n3. JSONFormatter (json_formatter.go):\n   - Update jsonTaskListItem: add Type field.\n   - FormatTaskList: populate Type.\n   - Update jsonTaskDetail: add Type field.\n   - FormatTaskDetail: populate Type.\n4. Formatter tests for all three.\n\nAcceptance Criteria:\n- Pretty list shows TYPE column with values or dash for unset\n- Pretty show includes Type: line\n- Toon list includes type field in schema and rows\n- Toon show includes type when set, omits when empty\n- JSON list includes \"type\" key in each item\n- JSON show includes \"type\" key\n- Column order in Pretty list: ID, STATUS, PRI, TYPE, TITLE\n- Existing formatter tests pass\n\nTests:\n- \"it shows type column in pretty list output\"\n- \"it shows dash for unset type in pretty list\"\n- \"it shows type in pretty show output\"\n- \"it shows dash for unset type in pretty show output\"\n- \"it includes type in toon list rows\"\n- \"it includes type in toon show when set\"\n- \"it omits type from toon show when empty\"\n- \"it includes type in json list items\"\n- \"it includes type in json show output\"\n- \"it includes empty type string in json list when unset\"\n\nEdge Cases:\n- Unset type: Pretty uses dash, Toon omits from show, JSON includes as empty string.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Task Types section, Display subsection","parent":"tick-ccdecb","created":"2026-02-28T10:27:44Z","updated":"2026-02-28T10:27:44Z"}
{"id":"tick-3e1ed5","title":"Add --count flag to list/ready/blocked","status":"open","priority":2,"description":"Problem: list, ready, and blocked commands return all matching tasks with no way to limit result count.\n\nSolution: Add Count int and HasCount bool to ListFilter, parse --count N in parseListFlags with validation (\u003e= 1), append LIMIT ? to SQL query in buildListQuery.\n\nOutcome: Users can run tick list --count 5 to see top N results. Works on list, ready, blocked. Invalid values produce clear errors.\n\nDo:\n1. Add Count int and HasCount bool to ListFilter (following Priority/HasPriority pattern).\n2. In parseListFlags, parse --count: read next arg, strconv.Atoi, store in f.Count, set f.HasCount = true.\n3. After parsing, if f.HasCount \u0026\u0026 f.Count \u003c 1, error.\n4. In buildListQuery, after ORDER BY: if f.HasCount, append LIMIT ? and f.Count to args.\n5. Tests for parsing and end-to-end count limiting.\n\nAcceptance Criteria:\n- tick list --count 5 returns at most 5 tasks\n- tick list --count 1 returns exactly 1 task (when tasks exist)\n- tick list --count 0 errors (must be \u003e= 1)\n- tick list --count -1 errors\n- tick list --count abc errors (non-integer)\n- tick list --count 100 with 3 tasks returns all 3 (no error)\n- tick ready --count 2 and tick blocked --count 2 work\n- tick list without --count returns all results\n- --count composes with other filters\n\nTests:\n- \"it limits list results with --count\"\n- \"it returns all tasks when --count exceeds result set size\"\n- \"it errors on --count 0\"\n- \"it errors on --count negative\"\n- \"it errors on --count non-integer\"\n- \"it errors on --count without value\"\n- \"it limits ready results with --count\"\n- \"it limits blocked results with --count\"\n- \"it combines --count with --type filter\"\n- \"it returns all results when --count not specified\"\n\nEdge Cases:\n- --count 0: error, must be \u003e= 1\n- --count -1: error\n- --count abc: parse error\n- --count 100 with only 3 tasks: returns all 3, SQL LIMIT handles gracefully\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- List Count/Limit section","parent":"tick-ccdecb","created":"2026-02-28T10:27:57Z","updated":"2026-02-28T10:27:57Z"}
{"id":"tick-f33a8b","title":"Phase 3: Tags","status":"open","priority":2,"parent":"tick-db58ad","created":"2026-02-28T10:40:24Z","updated":"2026-02-28T10:40:24Z"}
{"id":"tick-7d56c4","title":"Tags field on Task model with validation and JSONL serialization","status":"open","priority":2,"description":"Problem: Task model has no support for user-defined labels. No Tags field, no validation logic, no JSONL serialization.\n\nSolution: Add Tags []string to Task struct with json:\"tags,omitempty\", implement tag validation (kebab-case regex, max length, max count, dedup, normalization), update JSON marshal/unmarshal.\n\nOutcome: Task struct carries validated Tags field that serializes to/from JSONL. Validation functions available for CLI handlers.\n\nDo:\n- Add Tags []string to Task struct with json:\"tags,omitempty\" tag\n- Add Tags []string to taskJSON struct\n- Update MarshalJSON/UnmarshalJSON to copy Tags\n- Add constants: maxTagLength=30, maxTagsPerTask=10, tagPattern regex ^[a-z0-9]+(-[a-z0-9]+)*$\n- Implement NormalizeTag(tag string) string -- trim whitespace, lowercase\n- Implement ValidateTag(tag string) error -- non-empty, matches regex, max 30 chars\n- Implement ValidateTags(tags []string) error -- normalize, filter empties, dedup, validate each, check count \u003c= 10\n- Implement DeduplicateTags(tags []string) []string -- normalize, filter empties, dedup preserving order\n- Tests in internal/task/task_test.go or tags_test.go\n\nAcceptance Criteria:\n- Tags []string with json:\"tags,omitempty\" on Task struct\n- Tags round-trip through JSON marshal/unmarshal\n- Empty tags slice omitted from JSON (omitempty)\n- ValidateTag rejects: empty, double hyphens, leading/trailing hyphens, spaces, \u003e30 chars\n- ValidateTag accepts: frontend, ui-component, v2, a1-b2-c3\n- ValidateTags deduplicates before counting: 11 tags with 1 dup (10 unique) passes; 11 unique fails\n- NormalizeTag lowercases and trims\n- DeduplicateTags returns unique tags in first-occurrence order\n\nTests: 15 tests covering round-trip, omitempty, valid tags, regex rejections, normalization, dedup, max count, empty filtering.\n\nEdge Cases:\n- Double hyphens (my--tag): rejected by regex\n- Leading/trailing hyphens: rejected by regex anchors\n- Mixed-case: normalize before validation\n- 31-char tag: rejected by max length\n- 11 tags deduped to 10: passes\n- Empty string in list: filtered out\n- Tag with spaces: rejected by regex\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Tags section","parent":"tick-f33a8b","created":"2026-02-28T10:40:41Z","updated":"2026-02-28T10:40:41Z"}
{"id":"tick-17334e","title":"Tags junction table in SQLite schema and Cache.Rebuild","status":"open","priority":2,"description":"Problem: SQLite cache has no table for tags. Without task_tags junction table, tag-based filtering has no data to query against.\n\nSolution: Add task_tags(task_id, tag) junction table to SQLite schema, extend Cache.Rebuild() to insert tag rows per task during rebuild. Follow existing dependencies table pattern.\n\nOutcome: After rebuild, every task's tags stored in task_tags. Table cleared and repopulated on each rebuild. Schema creation idempotent.\n\nDo:\n- Add CREATE TABLE IF NOT EXISTS task_tags (task_id TEXT NOT NULL, tag TEXT NOT NULL, PRIMARY KEY (task_id, tag)) to schemaSQL\n- Add CREATE INDEX IF NOT EXISTS idx_task_tags_tag ON task_tags(tag)\n- In Cache.Rebuild(), add DELETE FROM task_tags alongside existing DELETEs\n- Prepare INSERT INTO task_tags (task_id, tag) VALUES (?, ?) like insertDep pattern\n- In task iteration loop, iterate t.Tags and insert each tag row\n- Tests in internal/storage/cache_test.go\n\nAcceptance Criteria:\n- task_tags table with composite PK (task_id, tag) and index on tag\n- Cache.Rebuild() inserts one row per tag per task\n- Cache.Rebuild() clears all task_tags before inserting\n- Empty Tags slice -\u003e zero rows\n- 3 tags -\u003e exactly 3 rows\n- Rebuild twice produces same result (idempotent)\n\nTests:\n- \"it creates task_tags table in schema\"\n- \"it populates task_tags during rebuild for task with tags\"\n- \"it inserts no rows for task with empty tags slice\"\n- \"it clears stale tags on rebuild\"\n- \"it handles rebuild with multiple tasks having different tag sets\"\n\nEdge Cases:\n- Empty tags slice: zero rows, no errors\n- Stale tags on rebuild: DELETE before INSERT ensures clean state\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Tags section: Storage (SQLite)","parent":"tick-f33a8b","created":"2026-02-28T10:40:53Z","updated":"2026-02-28T10:40:53Z"}
{"id":"tick-d17558","title":"Tags display in show output and all formatters","status":"open","priority":2,"description":"Problem: Tags exist on Task model and in SQLite cache but show command and formatters don't display them. Tags should appear in show/detail but not list output.\n\nSolution: Add tags to showData struct and queryShowData (query from task_tags), populate TaskDetail, update all three formatters' FormatTaskDetail. FormatTaskList unchanged.\n\nOutcome: tick show \u003cid\u003e displays tags in all formats. No tags -\u003e omit section (pretty/toon) or empty array (JSON).\n\nDo:\n- Add tags []string to showData struct in show.go\n- In queryShowData(), query SELECT tag FROM task_tags WHERE task_id = ? ORDER BY tag\n- Add Tags []string to TaskDetail struct in format.go\n- In showDataToTaskDetail(), copy data.tags to TaskDetail.Tags\n- PrettyFormatter.FormatTaskDetail: add Tags: tag1, tag2, tag3 line. Omit when empty.\n- ToonFormatter.FormatTaskDetail: add tags field as array. Omit when empty.\n- JSONFormatter.FormatTaskDetail: add Tags []string json:\"tags\" (always present, empty [] not null). Non-nil empty slice.\n- Tests in formatter test files and show test files\n\nAcceptance Criteria:\n- tick show \u003cid\u003e displays tags for task with tags\n- Omits tags section (pretty/toon) or shows empty array (JSON) for no tags\n- Pretty: Tags:     tag1, tag2, tag3 (comma-space separated)\n- Toon: tags field in task section\n- JSON: \"tags\" always present as array (empty [], never null)\n- Tags sorted alphabetically (ORDER BY tag)\n- 10 tags all displayed\n\nTests:\n- \"it displays tags in pretty format show output\"\n- \"it omits tags section in pretty format when task has no tags\"\n- \"it displays tags in toon format show output\"\n- \"it displays tags in json format show output\"\n- \"it shows empty tags array in json format when task has no tags\"\n- \"it displays all 10 tags when task has maximum tags\"\n- \"it displays tags in alphabetical order\"\n\nEdge Cases:\n- No tags: pretty/toon omit; JSON shows []\n- 10 tags: all displayed\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Tags section: Display","parent":"tick-f33a8b","created":"2026-02-28T10:41:05Z","updated":"2026-02-28T10:41:05Z"}
{"id":"tick-f713ec","title":"Create and update with --tags and --clear-tags flags","status":"open","priority":2,"description":"Problem: Users cannot assign or modify tags via create/update commands. Need --tags and --clear-tags flags.\n\nSolution: Add --tags \u003ccomma-separated\u003e to parseCreateArgs/parseUpdateArgs, --clear-tags to update only. Wire through DeduplicateTags and ValidateTags. Mutual exclusivity check.\n\nOutcome: tick create \"title\" --tags ui,backend sets tags. tick update \u003cid\u003e --tags api replaces. tick update \u003cid\u003e --clear-tags removes all. Validation errors for invalid/empty.\n\nDo:\n- create.go: Add tags []string and tagsRaw *string to createOpts. Parse --tags, split by comma, normalize. If empty value -\u003e error. Dedup+validate. Set newTask.Tags.\n- update.go: Add tags *[]string and clearTags bool to updateOpts. Update hasChanges(). Parse --tags and --clear-tags. Mutual exclusivity check. In mutation: clearTags -\u003e Tags=nil; tags provided -\u003e validated slice.\n- Update \"at least one flag\" error message to include --tags/--clear-tags.\n- Tests in create_test.go and update_test.go.\n\nAcceptance Criteria:\n- tick create \"title\" --tags ui,backend creates with Tags: [\"ui\", \"backend\"]\n- No --tags -\u003e nil/empty Tags\n- --tags \"\" -\u003e error\n- --tags \"ui,backend,ui\" deduplicates to [\"ui\", \"backend\"]\n- tick update \u003cid\u003e --tags api,frontend replaces all tags\n- tick update \u003cid\u003e --clear-tags removes all\n- --tags + --clear-tags -\u003e mutually exclusive error\n- --clear-tags on no-tags task succeeds (idempotent)\n- Invalid tags produce validation errors\n- Tags persisted to JSONL and visible in show output\n\nTests: 14 tests covering create with/without tags, empty value, dedup, normalization, invalid format, max count, update set/clear, mutual exclusivity, idempotent clear, output verification.\n\nEdge Cases:\n- --tags + --clear-tags: mutually exclusive error\n- Empty --tags: error (protective)\n- --tags with duplicates: silent dedup\n- --clear-tags on no-tags task: idempotent\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Tags section: CLI flags","parent":"tick-f33a8b","created":"2026-02-28T10:41:21Z","updated":"2026-02-28T10:41:21Z"}
{"id":"tick-56001c","title":"Tag filtering on list/ready/blocked with AND/OR composition","status":"open","priority":2,"description":"Problem: Users can assign tags but cannot filter lists by tag. Need --tag filter with AND/OR composition.\n\nSolution: Add --tag flag to parseListFlags collecting into TagGroups [][]string. Comma values = AND within flag, multiple --tag flags = OR. Extend buildListQuery with task_tags junction table subqueries using GROUP BY/HAVING COUNT for AND, OR for groups. Normalize and validate filter inputs.\n\nOutcome: tick list --tag ui (single tag), tick list --tag ui,backend (AND), tick list --tag ui,backend --tag api (OR groups). Composes with all existing filters.\n\nDo:\n- Add TagGroups [][]string to ListFilter in list.go\n- In parseListFlags, handle --tag: split by comma, normalize via task.NormalizeTag, append group to TagGroups. Multiple flags -\u003e multiple groups.\n- Validate each tag via task.ValidateTag after parsing\n- In buildListQuery, generate tag filter SQL:\n  - Single AND group [tag1, tag2]: t.id IN (SELECT task_id FROM task_tags WHERE tag IN (?,?) GROUP BY task_id HAVING COUNT(DISTINCT tag) = ?)\n  - Multiple OR groups: (subquery1 OR subquery2)\n- Ready/blocked inherit via existing delegation\n- Tests in list_filter_test.go or tag_filter_test.go\n\nAcceptance Criteria:\n- tick list --tag ui returns only tasks tagged ui\n- tick list --tag ui,backend returns tasks with both tags (AND)\n- tick list --tag ui,backend --tag api returns (ui AND backend) OR api\n- tick ready --tag ui and tick blocked --tag ui filter correctly\n- Composes with --status, --priority, --parent, --count\n- Invalid kebab-case in filter errors\n- No matching tasks returns empty list\n- Single --tag value works as single-element AND group\n\nTests: 14 tests covering single tag, AND, OR, composition, empty results, validation, normalization, combined filters.\n\nEdge Cases:\n- Invalid kebab-case: normalize first, then validate\n- No matches: empty list, not error\n- Single tag value: single-element AND group\n- Multiple --tag flags: each appended as separate OR group\n- Combined with other filters: tag conditions added as AND clauses composing naturally\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- Tags section: Filtering","parent":"tick-f33a8b","created":"2026-02-28T10:41:36Z","updated":"2026-02-28T10:41:36Z"}
{"id":"tick-af518b","title":"Phase 4: External References and Notes","status":"open","priority":2,"parent":"tick-db58ad","created":"2026-02-28T10:50:18Z","updated":"2026-02-28T10:50:18Z"}
{"id":"tick-e7bb22","title":"Refs field on Task model with validation and JSONL serialization","status":"open","priority":2,"description":"Problem: Tasks have no way to link to external systems. No Refs field, no validation logic.\n\nSolution: Add Refs []string to Task struct with json:\"refs,omitempty\", create validation functions, ensure JSONL round-trip.\n\nDo:\n- Add Refs []string to Task and taskJSON structs with json:\"refs,omitempty\"\n- Wire through MarshalJSON/UnmarshalJSON\n- Create internal/task/refs.go with:\n  - ValidateRef(ref string) error -- non-empty after trim, no commas, no whitespace, max 200 chars\n  - ValidateRefs(refs []string) error -- trim, validate each, dedup, check count \u003c= 10\n  - ParseRefs(input string) ([]string, error) -- split on comma, trim, dedup, validate\n- Tests in internal/task/refs_test.go\n\nAcceptance Criteria:\n- Refs []string with json:\"refs,omitempty\"\n- Empty refs omitted from JSON\n- Refs round-trip through marshal/unmarshal\n- Ref with comma rejected; ref with whitespace rejected\n- 200 chars accepted; 201 rejected\n- Empty/whitespace-only ref rejected\n- 11 refs deduped to 10 accepted; 11 unique rejected\n- Input trimmed before validation\n\nTests: 14 tests covering valid refs, comma/whitespace rejection, length boundaries, empty/whitespace, dedup, max count, trimming, JSON round-trip.\n\nEdge Cases: commas disallowed (CLI delimiter), whitespace disallowed (contiguous only), 200-char boundary, dedup before count check.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- External References section","parent":"tick-af518b","created":"2026-02-28T10:53:13Z","updated":"2026-02-28T10:53:13Z"}
{"id":"tick-80ad02","title":"Refs junction table in SQLite schema and Cache.Rebuild","status":"open","priority":2,"description":"Problem: SQLite cache has no table for refs. Cannot query or display refs via cache.\n\nSolution: Add task_refs(task_id, ref) junction table to schema, extend Cache.Rebuild() to insert refs per task. Follows dependencies and task_tags pattern.\n\nDo:\n- Add task_refs table to schemaSQL: task_id TEXT NOT NULL, ref TEXT NOT NULL, PRIMARY KEY (task_id, ref)\n- In Cache.Rebuild(), add DELETE FROM task_refs alongside existing DELETEs\n- Prepare INSERT INTO task_refs (task_id, ref) VALUES (?, ?)\n- In task loop, iterate t.Refs and insert each ref\n- Tests in internal/storage/cache_test.go\n\nAcceptance Criteria:\n- task_refs table with composite PK (task_id, ref)\n- Cache.Rebuild inserts one row per ref per task\n- Empty refs slice -\u003e zero rows\n- Rebuild clears stale refs before re-inserting\n\nTests:\n- \"it creates task_refs table in schema\"\n- \"it populates refs in task_refs during rebuild\"\n- \"it inserts no rows for task with empty refs slice\"\n- \"it clears stale refs on rebuild\"\n\nEdge Cases: empty refs -\u003e no rows; DELETE before INSERT removes stale data.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- External References, Storage","parent":"tick-af518b","created":"2026-02-28T10:53:28Z","updated":"2026-02-28T10:53:28Z"}
{"id":"tick-6d5863","title":"Create and update with --refs and --clear-refs flags","status":"open","priority":2,"description":"Problem: No way to attach external references during creation or updates.\n\nSolution: Add --refs \u003ccomma-separated\u003e to parseCreateArgs/parseUpdateArgs, --clear-refs to update. Wire through ParseRefs validation. Follow --tags/--clear-tags pattern from Phase 3.\n\nDo:\n- create.go: Add refs []string to createOpts. Parse --refs via task.ParseRefs(). Set newTask.Refs in mutation.\n- update.go: Add refs *[]string and clearRefs bool to updateOpts. Update hasChanges(). Parse --refs and --clear-refs. Mutual exclusivity check. Apply in mutation.\n- Update \"at least one flag\" error message.\n- Tests in create_test.go and update_test.go.\n\nAcceptance Criteria:\n- tick create \"title\" --refs gh-123,JIRA-456 creates with refs\n- tick update \u003cid\u003e --refs new-ref replaces all refs\n- tick update \u003cid\u003e --clear-refs removes all refs\n- --refs + --clear-refs -\u003e mutually exclusive error\n- Empty --refs value errors\n- Duplicates silently deduped\n- --clear-refs on no-refs task succeeds\n- Invalid refs produce validation errors\n\nTests: 9 tests covering create with/without refs, update replace/clear, mutual exclusivity, empty value, dedup, idempotent clear.\n\nEdge Cases: mutual exclusivity; empty value; dedup; clear on no-refs task.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- External References, CLI flags","parent":"tick-af518b","created":"2026-02-28T10:53:40Z","updated":"2026-02-28T10:53:40Z"}
{"id":"tick-4b4e4b","title":"Refs display in show output and all formatters","status":"open","priority":2,"description":"Problem: Show command doesn't query or display refs. No formatter renders refs.\n\nSolution: Extend queryShowData to query task_refs, add refs to showData and TaskDetail, update all three formatters' FormatTaskDetail. Show only, not list.\n\nDo:\n- format.go: Add Refs []string to TaskDetail\n- show.go: Add refs []string to showData. Query SELECT ref FROM task_refs WHERE task_id = ? ORDER BY ref. Copy to TaskDetail.\n- PrettyFormatter: Add Refs: section with indented refs. Omit when empty.\n- ToonFormatter: Add refs section. Empty -\u003e refs[0]:\n- JSONFormatter: Add Refs []string json:\"refs\" to jsonTaskDetail. Non-nil empty slice for [].\n- Formatter tests.\n\nAcceptance Criteria:\n- tick show \u003cid\u003e displays refs when present\n- Pretty: Refs: section with indented refs, omitted when empty\n- Toon: refs section, empty count when no refs\n- JSON: \"refs\": [] (never null)\n- 10 refs all displayed\n\nTests: 7 tests covering each formatter with/without refs, max refs.\n\nEdge Cases: no refs -\u003e omit/empty; 10 refs all rendered.\n\nSpec Reference: .workflows/specification/cli-enhancements/specification.md -- External References, Display","parent":"tick-af518b","created":"2026-02-28T10:53:53Z","updated":"2026-02-28T10:53:53Z"}
{"id":"tick-6cd164","title":"Note data model with validation and JSONL serialization","status":"open","priority":2,"parent":"tick-af518b","created":"2026-02-28T10:55:25Z","updated":"2026-02-28T10:55:25Z"}
{"id":"tick-17373b","title":"Notes table in SQLite schema and Cache.Rebuild","status":"open","priority":2,"parent":"tick-af518b","created":"2026-02-28T10:55:26Z","updated":"2026-02-28T10:55:26Z"}
{"id":"tick-a4c883","title":"Note add subcommand","status":"open","priority":2,"parent":"tick-af518b","created":"2026-02-28T10:55:27Z","updated":"2026-02-28T10:55:27Z"}
{"id":"tick-7402d4","title":"Note remove subcommand","status":"open","priority":2,"parent":"tick-af518b","created":"2026-02-28T10:55:28Z","updated":"2026-02-28T10:55:28Z"}
{"id":"tick-8b1edf","title":"Notes display in show output and all formatters","status":"open","priority":2,"parent":"tick-af518b","created":"2026-02-28T10:55:28Z","updated":"2026-02-28T10:55:28Z"}
